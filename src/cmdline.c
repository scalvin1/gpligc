/*
  File autogenerated by gengetopt version 2.22.6
  generated with the following command:
  gengetopt -G

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif


#include "cmdline.h"

const char *gengetopt_args_info_purpose = "OGIE (c) 2002-2021 by Hannes Krueger <Hannes.Krueger@gmail.com>\nWeb: http://gpligc.sf.net\n\nopenGL viewer for igc flight data files and/or digital elevation data\nfrom SRTM30, GTOPO30, GLOBE, etc. Digitised maps and airspace data\nfiles can be used.\n\nThis program comes with ABSOLUTELY NO WARRANTY.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions.\n\nThe full GPLv3 license is included in the manual\n";

const char *gengetopt_args_info_usage = "Usage: OGIE [OPTIONS]...";

const char *gengetopt_args_info_versiontext = "";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_help[] = {
  "  -h, --help                    Print help and exit",
  "  -V, --version                 Print version and exit",
  "  -v, --verbose                 verbosity?  (default=off)",
  "      --quiet                   Quiet  (default=off)",
  "  -q, --query-gl                Querying openGL implementation  (default=off)",
  "      --check                   return exitcode 0  (default=off)",
  "      --compiler                info about build  (default=off)",
  "      --debug                   lots of output  (default=off)",
  "  -i, --igc-file=STRING         igc-file",
  "      --gpsd                    live gps via gpsd  (default=off)",
  "      --gpsd-server=STRING      address of gpsd server",
  "      --gpsd-port=INT           port of gpsd server",
  "  -g, --gpsalt                  use gps altitude  (default=off)",
  "  -b, --baroalt                 use barometric alt  (default=off)",
  "      --use-all-fixes           Use all position fixes  (default=off)",
  "      --lat=FLOAT               Latitude",
  "      --lon=FLOAT               Longitude",
  "      --get-elevation           Return elevation of lat/lon  (default=off)",
  "  -c, --config-file=STRING      config file",
  "  -o, --ortho                   2D Orthographic View  (default=off)",
  "      --perspective             3D View  (default=off)",
  "      --aov=INT                 angle of view",
  "  -l, --landscape               landscape from dem  (default=off)",
  "  -f, --flat                    flat underground  (default=off)",
  "  -m, --map                     display digitized maps  (default=off)",
  "      --no-map                  dont use maps  (default=off)",
  "      --map-set-name=STRING     name of map set to use",
  "      --modulate                dem color and maps  (default=off)",
  "      --no-modulate             no color modulation  (default=off)",
  "      --maps-unlighted          dont use lighting for unmodulated maps\n                                  (default=off)",
  "      --maps-lighted            use lighting for unmodulated maps\n                                  (default=off)",
  "      --no-lighting             Dont use lighting for terrain  (default=off)",
  "      --terrain-shading         Use terrain shading (implies no-lighting)\n                                  (default=off)",
  "      --shading-scale=FLOAT     shading-scale (1-10000)",
  "      --light-direction=INT     direction for light (1-8)",
  "  -a, --airspace                Airspace visualization  (default=off)",
  "      --airspace-wire           Airspace as wireframe  (default=off)",
  "      --airspace-wire-col-r=FLOAT\n                                wire color red",
  "      --airspace-wire-col-g=FLOAT\n                                wire color green",
  "      --airspace-wire-col-b=FLOAT\n                                wire color blue",
  "      --airspace-wire-width=FLOAT\n                                linewidth wires",
  "      --airspace-transparent    Airspace transparent  (default=off)",
  "      --no-airspace             no Airspaces  (default=off)",
  "      --airspace-file=STRING    use airspaces from file",
  "      --airspace-limit=INT      limit (FL) for airspaces",
  "  -w, --wire                    wireframe landscape  (default=off)",
  "      --filled                  filled polygons  (default=off)",
  "      --grayscale               grayscaled image  (default=off)",
  "      --color                   color image  (default=off)",
  "      --stereo                  stereoscopic  (default=off)",
  "      --no-stereo               no stereoscopic view  (default=off)",
  "      --stereo-rg               stereoscopic red/green  (default=off)",
  "      --no-stereo-rg            no stereoscopic red/green  (default=off)",
  "      --stereo-rb               stereoscopic red/blue  (default=off)",
  "      --no-stereo-rb            no stereoscopic red/blue  (default=off)",
  "      --stereo-hw               stereoscopic hardware  (default=off)",
  "      --no-stereo-hw            no stereoscopic hardware  (default=off)",
  "      --inverse-stereo          invert right/left image  (default=off)",
  "      --no-inverse-stereo       dont invert right/left  (default=off)",
  "      --eye-dist=FLOAT          eye distance for stereoscopic view (km)",
  "      --flat-shading            no gouraud  (default=off)",
  "      --gouraud-shading         use gouraud-shading  (default=off)",
  "      --quads                   use quadrilaterals  (default=off)",
  "      --curtain                 draw curtain  (default=off)",
  "      --no-curtain              draw no curtain  (default=off)",
  "      --haze                    draw haze  (default=off)",
  "      --no-haze                 draw no haze  (default=off)",
  "      --haze-density=FLOAT      haze density (0-0.5)",
  "      --colormap=INT            no. of colormap to use",
  "      --colormap-sea=INT        colormap 2 (sea)",
  "      --colormap-min=INT        mininum height",
  "      --colormap-max=INT        maximum height",
  "      --sealevel=INT            set sealevel",
  "      --sealevel2=INT           set sealevel2",
  "      --sealevel3=INT           set sealevel3",
  "      --ignore-elev-min=INT     ignore range min",
  "      --ignore-elev-max=INT     ignore range max",
  "  -s, --scalez=FLOAT            z axis scaling",
  "  -d, --downscaling=INT         dem raster downscaling",
  "      --upscaling=INT           dem raster interpolation factor",
  "      --fullscreen              Fullscreen  (default=off)",
  "      --window                  start windowed  (default=off)",
  "      --width=INT               Window width",
  "      --height=INT              Window height",
  "      --border=FLOAT            Border Lat and Lon",
  "      --border-lat=FLOAT        Border Lat",
  "      --border-lon=FLOAT        Border Lon",
  "      --offset=INT              height offset in m",
  "  -e, --airfield-elevation=INT  Elevation of airfield (take-off) in m",
  "      --marker-pos=INT          Position of marker",
  "      --marker-time=STRING      Time of markerposition",
  "      --marker                  Marker  (default=off)",
  "      --marker-size=FLOAT       Size of the Marker",
  "      --no-marker               no Marker  (default=off)",
  "      --info                    Info text display  (default=off)",
  "      --no-info                 no info text display  (default=off)",
  "      --text=STRING             Text string to display",
  "      --no-position-info        Turn off viewpoint position info  (default=off)",
  "      --no-marker-pos-info      Turn off marker position info  (default=off)",
  "      --text-size=FLOAT         Size of text for points/lifts (0.001-1.0)",
  "      --text-width=FLOAT        Width of text (1-20)",
  "      --lifts=STRING            GPLIGC liftsfile",
  "      --lifts-info-mode=INT     which info to display (1-7)",
  "      --waypoints-file=STRING   waypointsfile",
  "      --waypoints               show waypoints  (default=off)",
  "      --no-waypoints            dont show waypoints  (default=off)",
  "      --waypoints-info-mode=INT which info to display (1-4)",
  "      --waypoints-offset=INT    offset for displaying waypoint text in 3D",
  "      --waypoints-offset-spheres=INT\n                                offset for displaying waypoint spheres and text\n                                  in 3D",
  "      --flighttrack-mode=INT    sets the mode of track display",
  "      --flighttrack-colormap=INT\n                                sets the colourmap for flighttrack",
  "      --flighttrack-linewidth=FLOAT\n                                sets the linewidth of the flighttrack",
  "      --follow                  viewpoint follows marker  (default=off)",
  "      --no-follow               viewpoint doesnt follow marker  (default=off)",
  "      --marker-range            range around marker is plottet  (default=off)",
  "      --no-marker-range         full flight is displayed  (default=off)",
  "      --marker-ahead=INT        define marker range",
  "      --marker-back=INT         define marker range",
  "      --movie                   start up in movie mode  (default=off)",
  "      --cycles=INT              cycles for movie mode",
  "      --spinning=FLOAT          spinning for movie mode",
  "      --smooth-mouse            smooth movement  (default=off)",
  "      --parent-pid=INT          PID of parent",
  "      --compression             Use texture map compression  (default=off)",
  "      --no-compression          Dont use texture map compression  (default=off)",
  "      --offscreen               Offscreen with GLX  (default=off)",
  "      --osmesa                  Offscreen with Mesa  (default=off)",
  "      --os-outfile=STRING       outfile for offscreen rendering",
  "      --jpeg-quality=INT        Quality (0-100) of jpeg output",
  "      --image-format=STRING     Image format for screenshots",
  "      --save-path=STRING        Path to save screenshots",
  "      --basename=STRING         Basename of screenshots",
  "      --clipping-far=FLOAT      clipping far",
  "      --clipping-near=FLOAT     clipping near",
  "      --init-lat=FLOAT          set initial latitude",
  "      --init-lon=FLOAT          set initial longitude",
  "      --init-alt=INT            set initial altitude",
  "      --init-heading=INT        set initial heading",
  "      --init-dive=INT           set initial dive angle",
  "      --init-pos-N              set position North  (default=off)",
  "      --init-pos-E              set position East  (default=off)",
  "      --init-pos-S              set position South  (default=off)",
  "      --init-pos-W              set position West  (default=off)",
  "      --init-pos-NE             set position NE  (default=off)",
  "      --init-pos-SE             set position SE  (default=off)",
  "      --init-pos-SW             set position SW  (default=off)",
  "      --init-pos-NW             set position NW  (default=off)",
  "      --init-pos-center         set position center  (default=off)",
  "      --init-ortho-lat=FLOAT    set initial latitude for ortho mode",
  "      --init-ortho-lon=FLOAT    set initial longitude for ortho mode",
  "      --init-ortho-width=FLOAT  set initial ortho-view width [km]",
  "      --projection-cyl-platt    set platt projection  (default=off)",
  "      --projection-cyl-no1      set cylindric projection 1  (default=off)",
  "      --projection-pseudo-cyl-no1\n                                set pseudocylindric projection 1  (default=off)",
  "      --projection-cyl-mercator set mercator projection  (default=off)",
    0
};

typedef enum {ARG_NO
  , ARG_FLAG
  , ARG_STRING
  , ARG_INT
  , ARG_FLOAT
} cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error);


static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->verbose_given = 0 ;
  args_info->quiet_given = 0 ;
  args_info->query_gl_given = 0 ;
  args_info->check_given = 0 ;
  args_info->compiler_given = 0 ;
  args_info->debug_given = 0 ;
  args_info->igc_file_given = 0 ;
  args_info->gpsd_given = 0 ;
  args_info->gpsd_server_given = 0 ;
  args_info->gpsd_port_given = 0 ;
  args_info->gpsalt_given = 0 ;
  args_info->baroalt_given = 0 ;
  args_info->use_all_fixes_given = 0 ;
  args_info->lat_given = 0 ;
  args_info->lon_given = 0 ;
  args_info->get_elevation_given = 0 ;
  args_info->config_file_given = 0 ;
  args_info->ortho_given = 0 ;
  args_info->perspective_given = 0 ;
  args_info->aov_given = 0 ;
  args_info->landscape_given = 0 ;
  args_info->flat_given = 0 ;
  args_info->map_given = 0 ;
  args_info->no_map_given = 0 ;
  args_info->map_set_name_given = 0 ;
  args_info->modulate_given = 0 ;
  args_info->no_modulate_given = 0 ;
  args_info->maps_unlighted_given = 0 ;
  args_info->maps_lighted_given = 0 ;
  args_info->no_lighting_given = 0 ;
  args_info->terrain_shading_given = 0 ;
  args_info->shading_scale_given = 0 ;
  args_info->light_direction_given = 0 ;
  args_info->airspace_given = 0 ;
  args_info->airspace_wire_given = 0 ;
  args_info->airspace_wire_col_r_given = 0 ;
  args_info->airspace_wire_col_g_given = 0 ;
  args_info->airspace_wire_col_b_given = 0 ;
  args_info->airspace_wire_width_given = 0 ;
  args_info->airspace_transparent_given = 0 ;
  args_info->no_airspace_given = 0 ;
  args_info->airspace_file_given = 0 ;
  args_info->airspace_limit_given = 0 ;
  args_info->wire_given = 0 ;
  args_info->filled_given = 0 ;
  args_info->grayscale_given = 0 ;
  args_info->color_given = 0 ;
  args_info->stereo_given = 0 ;
  args_info->no_stereo_given = 0 ;
  args_info->stereo_rg_given = 0 ;
  args_info->no_stereo_rg_given = 0 ;
  args_info->stereo_rb_given = 0 ;
  args_info->no_stereo_rb_given = 0 ;
  args_info->stereo_hw_given = 0 ;
  args_info->no_stereo_hw_given = 0 ;
  args_info->inverse_stereo_given = 0 ;
  args_info->no_inverse_stereo_given = 0 ;
  args_info->eye_dist_given = 0 ;
  args_info->flat_shading_given = 0 ;
  args_info->gouraud_shading_given = 0 ;
  args_info->quads_given = 0 ;
  args_info->curtain_given = 0 ;
  args_info->no_curtain_given = 0 ;
  args_info->haze_given = 0 ;
  args_info->no_haze_given = 0 ;
  args_info->haze_density_given = 0 ;
  args_info->colormap_given = 0 ;
  args_info->colormap_sea_given = 0 ;
  args_info->colormap_min_given = 0 ;
  args_info->colormap_max_given = 0 ;
  args_info->sealevel_given = 0 ;
  args_info->sealevel2_given = 0 ;
  args_info->sealevel3_given = 0 ;
  args_info->ignore_elev_min_given = 0 ;
  args_info->ignore_elev_max_given = 0 ;
  args_info->scalez_given = 0 ;
  args_info->downscaling_given = 0 ;
  args_info->upscaling_given = 0 ;
  args_info->fullscreen_given = 0 ;
  args_info->window_given = 0 ;
  args_info->width_given = 0 ;
  args_info->height_given = 0 ;
  args_info->border_given = 0 ;
  args_info->border_lat_given = 0 ;
  args_info->border_lon_given = 0 ;
  args_info->offset_given = 0 ;
  args_info->airfield_elevation_given = 0 ;
  args_info->marker_pos_given = 0 ;
  args_info->marker_time_given = 0 ;
  args_info->marker_given = 0 ;
  args_info->marker_size_given = 0 ;
  args_info->no_marker_given = 0 ;
  args_info->info_given = 0 ;
  args_info->no_info_given = 0 ;
  args_info->text_given = 0 ;
  args_info->no_position_info_given = 0 ;
  args_info->no_marker_pos_info_given = 0 ;
  args_info->text_size_given = 0 ;
  args_info->text_width_given = 0 ;
  args_info->lifts_given = 0 ;
  args_info->lifts_info_mode_given = 0 ;
  args_info->waypoints_file_given = 0 ;
  args_info->waypoints_given = 0 ;
  args_info->no_waypoints_given = 0 ;
  args_info->waypoints_info_mode_given = 0 ;
  args_info->waypoints_offset_given = 0 ;
  args_info->waypoints_offset_spheres_given = 0 ;
  args_info->flighttrack_mode_given = 0 ;
  args_info->flighttrack_colormap_given = 0 ;
  args_info->flighttrack_linewidth_given = 0 ;
  args_info->follow_given = 0 ;
  args_info->no_follow_given = 0 ;
  args_info->marker_range_given = 0 ;
  args_info->no_marker_range_given = 0 ;
  args_info->marker_ahead_given = 0 ;
  args_info->marker_back_given = 0 ;
  args_info->movie_given = 0 ;
  args_info->cycles_given = 0 ;
  args_info->spinning_given = 0 ;
  args_info->smooth_mouse_given = 0 ;
  args_info->parent_pid_given = 0 ;
  args_info->compression_given = 0 ;
  args_info->no_compression_given = 0 ;
  args_info->offscreen_given = 0 ;
  args_info->osmesa_given = 0 ;
  args_info->os_outfile_given = 0 ;
  args_info->jpeg_quality_given = 0 ;
  args_info->image_format_given = 0 ;
  args_info->save_path_given = 0 ;
  args_info->basename_given = 0 ;
  args_info->clipping_far_given = 0 ;
  args_info->clipping_near_given = 0 ;
  args_info->init_lat_given = 0 ;
  args_info->init_lon_given = 0 ;
  args_info->init_alt_given = 0 ;
  args_info->init_heading_given = 0 ;
  args_info->init_dive_given = 0 ;
  args_info->init_pos_N_given = 0 ;
  args_info->init_pos_E_given = 0 ;
  args_info->init_pos_S_given = 0 ;
  args_info->init_pos_W_given = 0 ;
  args_info->init_pos_NE_given = 0 ;
  args_info->init_pos_SE_given = 0 ;
  args_info->init_pos_SW_given = 0 ;
  args_info->init_pos_NW_given = 0 ;
  args_info->init_pos_center_given = 0 ;
  args_info->init_ortho_lat_given = 0 ;
  args_info->init_ortho_lon_given = 0 ;
  args_info->init_ortho_width_given = 0 ;
  args_info->projection_cyl_platt_given = 0 ;
  args_info->projection_cyl_no1_given = 0 ;
  args_info->projection_pseudo_cyl_no1_given = 0 ;
  args_info->projection_cyl_mercator_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->verbose_flag = 0;
  args_info->quiet_flag = 0;
  args_info->query_gl_flag = 0;
  args_info->check_flag = 0;
  args_info->compiler_flag = 0;
  args_info->debug_flag = 0;
  args_info->igc_file_arg = NULL;
  args_info->igc_file_orig = NULL;
  args_info->gpsd_flag = 0;
  args_info->gpsd_server_arg = NULL;
  args_info->gpsd_server_orig = NULL;
  args_info->gpsd_port_orig = NULL;
  args_info->gpsalt_flag = 0;
  args_info->baroalt_flag = 0;
  args_info->use_all_fixes_flag = 0;
  args_info->lat_orig = NULL;
  args_info->lon_orig = NULL;
  args_info->get_elevation_flag = 0;
  args_info->config_file_arg = NULL;
  args_info->config_file_orig = NULL;
  args_info->ortho_flag = 0;
  args_info->perspective_flag = 0;
  args_info->aov_orig = NULL;
  args_info->landscape_flag = 0;
  args_info->flat_flag = 0;
  args_info->map_flag = 0;
  args_info->no_map_flag = 0;
  args_info->map_set_name_arg = NULL;
  args_info->map_set_name_orig = NULL;
  args_info->modulate_flag = 0;
  args_info->no_modulate_flag = 0;
  args_info->maps_unlighted_flag = 0;
  args_info->maps_lighted_flag = 0;
  args_info->no_lighting_flag = 0;
  args_info->terrain_shading_flag = 0;
  args_info->shading_scale_orig = NULL;
  args_info->light_direction_orig = NULL;
  args_info->airspace_flag = 0;
  args_info->airspace_wire_flag = 0;
  args_info->airspace_wire_col_r_orig = NULL;
  args_info->airspace_wire_col_g_orig = NULL;
  args_info->airspace_wire_col_b_orig = NULL;
  args_info->airspace_wire_width_orig = NULL;
  args_info->airspace_transparent_flag = 0;
  args_info->no_airspace_flag = 0;
  args_info->airspace_file_arg = NULL;
  args_info->airspace_file_orig = NULL;
  args_info->airspace_limit_orig = NULL;
  args_info->wire_flag = 0;
  args_info->filled_flag = 0;
  args_info->grayscale_flag = 0;
  args_info->color_flag = 0;
  args_info->stereo_flag = 0;
  args_info->no_stereo_flag = 0;
  args_info->stereo_rg_flag = 0;
  args_info->no_stereo_rg_flag = 0;
  args_info->stereo_rb_flag = 0;
  args_info->no_stereo_rb_flag = 0;
  args_info->stereo_hw_flag = 0;
  args_info->no_stereo_hw_flag = 0;
  args_info->inverse_stereo_flag = 0;
  args_info->no_inverse_stereo_flag = 0;
  args_info->eye_dist_orig = NULL;
  args_info->flat_shading_flag = 0;
  args_info->gouraud_shading_flag = 0;
  args_info->quads_flag = 0;
  args_info->curtain_flag = 0;
  args_info->no_curtain_flag = 0;
  args_info->haze_flag = 0;
  args_info->no_haze_flag = 0;
  args_info->haze_density_orig = NULL;
  args_info->colormap_orig = NULL;
  args_info->colormap_sea_orig = NULL;
  args_info->colormap_min_orig = NULL;
  args_info->colormap_max_orig = NULL;
  args_info->sealevel_orig = NULL;
  args_info->sealevel2_orig = NULL;
  args_info->sealevel3_orig = NULL;
  args_info->ignore_elev_min_orig = NULL;
  args_info->ignore_elev_max_orig = NULL;
  args_info->scalez_orig = NULL;
  args_info->downscaling_orig = NULL;
  args_info->upscaling_orig = NULL;
  args_info->fullscreen_flag = 0;
  args_info->window_flag = 0;
  args_info->width_orig = NULL;
  args_info->height_orig = NULL;
  args_info->border_orig = NULL;
  args_info->border_lat_orig = NULL;
  args_info->border_lon_orig = NULL;
  args_info->offset_orig = NULL;
  args_info->airfield_elevation_orig = NULL;
  args_info->marker_pos_orig = NULL;
  args_info->marker_time_arg = NULL;
  args_info->marker_time_orig = NULL;
  args_info->marker_flag = 0;
  args_info->marker_size_orig = NULL;
  args_info->no_marker_flag = 0;
  args_info->info_flag = 0;
  args_info->no_info_flag = 0;
  args_info->text_arg = NULL;
  args_info->text_orig = NULL;
  args_info->no_position_info_flag = 0;
  args_info->no_marker_pos_info_flag = 0;
  args_info->text_size_orig = NULL;
  args_info->text_width_orig = NULL;
  args_info->lifts_arg = NULL;
  args_info->lifts_orig = NULL;
  args_info->lifts_info_mode_orig = NULL;
  args_info->waypoints_file_arg = NULL;
  args_info->waypoints_file_orig = NULL;
  args_info->waypoints_flag = 0;
  args_info->no_waypoints_flag = 0;
  args_info->waypoints_info_mode_orig = NULL;
  args_info->waypoints_offset_orig = NULL;
  args_info->waypoints_offset_spheres_orig = NULL;
  args_info->flighttrack_mode_orig = NULL;
  args_info->flighttrack_colormap_orig = NULL;
  args_info->flighttrack_linewidth_orig = NULL;
  args_info->follow_flag = 0;
  args_info->no_follow_flag = 0;
  args_info->marker_range_flag = 0;
  args_info->no_marker_range_flag = 0;
  args_info->marker_ahead_orig = NULL;
  args_info->marker_back_orig = NULL;
  args_info->movie_flag = 0;
  args_info->cycles_orig = NULL;
  args_info->spinning_orig = NULL;
  args_info->smooth_mouse_flag = 0;
  args_info->parent_pid_orig = NULL;
  args_info->compression_flag = 0;
  args_info->no_compression_flag = 0;
  args_info->offscreen_flag = 0;
  args_info->osmesa_flag = 0;
  args_info->os_outfile_arg = NULL;
  args_info->os_outfile_orig = NULL;
  args_info->jpeg_quality_orig = NULL;
  args_info->image_format_arg = NULL;
  args_info->image_format_orig = NULL;
  args_info->save_path_arg = NULL;
  args_info->save_path_orig = NULL;
  args_info->basename_arg = NULL;
  args_info->basename_orig = NULL;
  args_info->clipping_far_orig = NULL;
  args_info->clipping_near_orig = NULL;
  args_info->init_lat_orig = NULL;
  args_info->init_lon_orig = NULL;
  args_info->init_alt_orig = NULL;
  args_info->init_heading_orig = NULL;
  args_info->init_dive_orig = NULL;
  args_info->init_pos_N_flag = 0;
  args_info->init_pos_E_flag = 0;
  args_info->init_pos_S_flag = 0;
  args_info->init_pos_W_flag = 0;
  args_info->init_pos_NE_flag = 0;
  args_info->init_pos_SE_flag = 0;
  args_info->init_pos_SW_flag = 0;
  args_info->init_pos_NW_flag = 0;
  args_info->init_pos_center_flag = 0;
  args_info->init_ortho_lat_orig = NULL;
  args_info->init_ortho_lon_orig = NULL;
  args_info->init_ortho_width_orig = NULL;
  args_info->projection_cyl_platt_flag = 0;
  args_info->projection_cyl_no1_flag = 0;
  args_info->projection_pseudo_cyl_no1_flag = 0;
  args_info->projection_cyl_mercator_flag = 0;

}

static
void init_args_info(struct gengetopt_args_info *args_info)
{


  args_info->help_help = gengetopt_args_info_help[0] ;
  args_info->version_help = gengetopt_args_info_help[1] ;
  args_info->verbose_help = gengetopt_args_info_help[2] ;
  args_info->quiet_help = gengetopt_args_info_help[3] ;
  args_info->query_gl_help = gengetopt_args_info_help[4] ;
  args_info->check_help = gengetopt_args_info_help[5] ;
  args_info->compiler_help = gengetopt_args_info_help[6] ;
  args_info->debug_help = gengetopt_args_info_help[7] ;
  args_info->igc_file_help = gengetopt_args_info_help[8] ;
  args_info->gpsd_help = gengetopt_args_info_help[9] ;
  args_info->gpsd_server_help = gengetopt_args_info_help[10] ;
  args_info->gpsd_port_help = gengetopt_args_info_help[11] ;
  args_info->gpsalt_help = gengetopt_args_info_help[12] ;
  args_info->baroalt_help = gengetopt_args_info_help[13] ;
  args_info->use_all_fixes_help = gengetopt_args_info_help[14] ;
  args_info->lat_help = gengetopt_args_info_help[15] ;
  args_info->lon_help = gengetopt_args_info_help[16] ;
  args_info->get_elevation_help = gengetopt_args_info_help[17] ;
  args_info->config_file_help = gengetopt_args_info_help[18] ;
  args_info->ortho_help = gengetopt_args_info_help[19] ;
  args_info->perspective_help = gengetopt_args_info_help[20] ;
  args_info->aov_help = gengetopt_args_info_help[21] ;
  args_info->landscape_help = gengetopt_args_info_help[22] ;
  args_info->flat_help = gengetopt_args_info_help[23] ;
  args_info->map_help = gengetopt_args_info_help[24] ;
  args_info->no_map_help = gengetopt_args_info_help[25] ;
  args_info->map_set_name_help = gengetopt_args_info_help[26] ;
  args_info->modulate_help = gengetopt_args_info_help[27] ;
  args_info->no_modulate_help = gengetopt_args_info_help[28] ;
  args_info->maps_unlighted_help = gengetopt_args_info_help[29] ;
  args_info->maps_lighted_help = gengetopt_args_info_help[30] ;
  args_info->no_lighting_help = gengetopt_args_info_help[31] ;
  args_info->terrain_shading_help = gengetopt_args_info_help[32] ;
  args_info->shading_scale_help = gengetopt_args_info_help[33] ;
  args_info->light_direction_help = gengetopt_args_info_help[34] ;
  args_info->airspace_help = gengetopt_args_info_help[35] ;
  args_info->airspace_wire_help = gengetopt_args_info_help[36] ;
  args_info->airspace_wire_col_r_help = gengetopt_args_info_help[37] ;
  args_info->airspace_wire_col_g_help = gengetopt_args_info_help[38] ;
  args_info->airspace_wire_col_b_help = gengetopt_args_info_help[39] ;
  args_info->airspace_wire_width_help = gengetopt_args_info_help[40] ;
  args_info->airspace_transparent_help = gengetopt_args_info_help[41] ;
  args_info->no_airspace_help = gengetopt_args_info_help[42] ;
  args_info->airspace_file_help = gengetopt_args_info_help[43] ;
  args_info->airspace_limit_help = gengetopt_args_info_help[44] ;
  args_info->wire_help = gengetopt_args_info_help[45] ;
  args_info->filled_help = gengetopt_args_info_help[46] ;
  args_info->grayscale_help = gengetopt_args_info_help[47] ;
  args_info->color_help = gengetopt_args_info_help[48] ;
  args_info->stereo_help = gengetopt_args_info_help[49] ;
  args_info->no_stereo_help = gengetopt_args_info_help[50] ;
  args_info->stereo_rg_help = gengetopt_args_info_help[51] ;
  args_info->no_stereo_rg_help = gengetopt_args_info_help[52] ;
  args_info->stereo_rb_help = gengetopt_args_info_help[53] ;
  args_info->no_stereo_rb_help = gengetopt_args_info_help[54] ;
  args_info->stereo_hw_help = gengetopt_args_info_help[55] ;
  args_info->no_stereo_hw_help = gengetopt_args_info_help[56] ;
  args_info->inverse_stereo_help = gengetopt_args_info_help[57] ;
  args_info->no_inverse_stereo_help = gengetopt_args_info_help[58] ;
  args_info->eye_dist_help = gengetopt_args_info_help[59] ;
  args_info->flat_shading_help = gengetopt_args_info_help[60] ;
  args_info->gouraud_shading_help = gengetopt_args_info_help[61] ;
  args_info->quads_help = gengetopt_args_info_help[62] ;
  args_info->curtain_help = gengetopt_args_info_help[63] ;
  args_info->no_curtain_help = gengetopt_args_info_help[64] ;
  args_info->haze_help = gengetopt_args_info_help[65] ;
  args_info->no_haze_help = gengetopt_args_info_help[66] ;
  args_info->haze_density_help = gengetopt_args_info_help[67] ;
  args_info->colormap_help = gengetopt_args_info_help[68] ;
  args_info->colormap_sea_help = gengetopt_args_info_help[69] ;
  args_info->colormap_min_help = gengetopt_args_info_help[70] ;
  args_info->colormap_max_help = gengetopt_args_info_help[71] ;
  args_info->sealevel_help = gengetopt_args_info_help[72] ;
  args_info->sealevel2_help = gengetopt_args_info_help[73] ;
  args_info->sealevel3_help = gengetopt_args_info_help[74] ;
  args_info->ignore_elev_min_help = gengetopt_args_info_help[75] ;
  args_info->ignore_elev_max_help = gengetopt_args_info_help[76] ;
  args_info->scalez_help = gengetopt_args_info_help[77] ;
  args_info->downscaling_help = gengetopt_args_info_help[78] ;
  args_info->upscaling_help = gengetopt_args_info_help[79] ;
  args_info->fullscreen_help = gengetopt_args_info_help[80] ;
  args_info->window_help = gengetopt_args_info_help[81] ;
  args_info->width_help = gengetopt_args_info_help[82] ;
  args_info->height_help = gengetopt_args_info_help[83] ;
  args_info->border_help = gengetopt_args_info_help[84] ;
  args_info->border_lat_help = gengetopt_args_info_help[85] ;
  args_info->border_lon_help = gengetopt_args_info_help[86] ;
  args_info->offset_help = gengetopt_args_info_help[87] ;
  args_info->airfield_elevation_help = gengetopt_args_info_help[88] ;
  args_info->marker_pos_help = gengetopt_args_info_help[89] ;
  args_info->marker_time_help = gengetopt_args_info_help[90] ;
  args_info->marker_help = gengetopt_args_info_help[91] ;
  args_info->marker_size_help = gengetopt_args_info_help[92] ;
  args_info->no_marker_help = gengetopt_args_info_help[93] ;
  args_info->info_help = gengetopt_args_info_help[94] ;
  args_info->no_info_help = gengetopt_args_info_help[95] ;
  args_info->text_help = gengetopt_args_info_help[96] ;
  args_info->no_position_info_help = gengetopt_args_info_help[97] ;
  args_info->no_marker_pos_info_help = gengetopt_args_info_help[98] ;
  args_info->text_size_help = gengetopt_args_info_help[99] ;
  args_info->text_width_help = gengetopt_args_info_help[100] ;
  args_info->lifts_help = gengetopt_args_info_help[101] ;
  args_info->lifts_info_mode_help = gengetopt_args_info_help[102] ;
  args_info->waypoints_file_help = gengetopt_args_info_help[103] ;
  args_info->waypoints_help = gengetopt_args_info_help[104] ;
  args_info->no_waypoints_help = gengetopt_args_info_help[105] ;
  args_info->waypoints_info_mode_help = gengetopt_args_info_help[106] ;
  args_info->waypoints_offset_help = gengetopt_args_info_help[107] ;
  args_info->waypoints_offset_spheres_help = gengetopt_args_info_help[108] ;
  args_info->flighttrack_mode_help = gengetopt_args_info_help[109] ;
  args_info->flighttrack_colormap_help = gengetopt_args_info_help[110] ;
  args_info->flighttrack_linewidth_help = gengetopt_args_info_help[111] ;
  args_info->follow_help = gengetopt_args_info_help[112] ;
  args_info->no_follow_help = gengetopt_args_info_help[113] ;
  args_info->marker_range_help = gengetopt_args_info_help[114] ;
  args_info->no_marker_range_help = gengetopt_args_info_help[115] ;
  args_info->marker_ahead_help = gengetopt_args_info_help[116] ;
  args_info->marker_back_help = gengetopt_args_info_help[117] ;
  args_info->movie_help = gengetopt_args_info_help[118] ;
  args_info->cycles_help = gengetopt_args_info_help[119] ;
  args_info->spinning_help = gengetopt_args_info_help[120] ;
  args_info->smooth_mouse_help = gengetopt_args_info_help[121] ;
  args_info->parent_pid_help = gengetopt_args_info_help[122] ;
  args_info->compression_help = gengetopt_args_info_help[123] ;
  args_info->no_compression_help = gengetopt_args_info_help[124] ;
  args_info->offscreen_help = gengetopt_args_info_help[125] ;
  args_info->osmesa_help = gengetopt_args_info_help[126] ;
  args_info->os_outfile_help = gengetopt_args_info_help[127] ;
  args_info->jpeg_quality_help = gengetopt_args_info_help[128] ;
  args_info->image_format_help = gengetopt_args_info_help[129] ;
  args_info->save_path_help = gengetopt_args_info_help[130] ;
  args_info->basename_help = gengetopt_args_info_help[131] ;
  args_info->clipping_far_help = gengetopt_args_info_help[132] ;
  args_info->clipping_near_help = gengetopt_args_info_help[133] ;
  args_info->init_lat_help = gengetopt_args_info_help[134] ;
  args_info->init_lon_help = gengetopt_args_info_help[135] ;
  args_info->init_alt_help = gengetopt_args_info_help[136] ;
  args_info->init_heading_help = gengetopt_args_info_help[137] ;
  args_info->init_dive_help = gengetopt_args_info_help[138] ;
  args_info->init_pos_N_help = gengetopt_args_info_help[139] ;
  args_info->init_pos_E_help = gengetopt_args_info_help[140] ;
  args_info->init_pos_S_help = gengetopt_args_info_help[141] ;
  args_info->init_pos_W_help = gengetopt_args_info_help[142] ;
  args_info->init_pos_NE_help = gengetopt_args_info_help[143] ;
  args_info->init_pos_SE_help = gengetopt_args_info_help[144] ;
  args_info->init_pos_SW_help = gengetopt_args_info_help[145] ;
  args_info->init_pos_NW_help = gengetopt_args_info_help[146] ;
  args_info->init_pos_center_help = gengetopt_args_info_help[147] ;
  args_info->init_ortho_lat_help = gengetopt_args_info_help[148] ;
  args_info->init_ortho_lon_help = gengetopt_args_info_help[149] ;
  args_info->init_ortho_width_help = gengetopt_args_info_help[150] ;
  args_info->projection_cyl_platt_help = gengetopt_args_info_help[151] ;
  args_info->projection_cyl_no1_help = gengetopt_args_info_help[152] ;
  args_info->projection_pseudo_cyl_no1_help = gengetopt_args_info_help[153] ;
  args_info->projection_cyl_mercator_help = gengetopt_args_info_help[154] ;

}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
     CMDLINE_PARSER_VERSION);

  if (strlen(gengetopt_args_info_versiontext) > 0)
    printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void) {
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n\n", gengetopt_args_info_description);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);
}

void
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
  if (params)
    {
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct cmdline_parser_params *
cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params =
    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
  cmdline_parser_params_init(params);
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}


static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{

  free_string_field (&(args_info->igc_file_arg));
  free_string_field (&(args_info->igc_file_orig));
  free_string_field (&(args_info->gpsd_server_arg));
  free_string_field (&(args_info->gpsd_server_orig));
  free_string_field (&(args_info->gpsd_port_orig));
  free_string_field (&(args_info->lat_orig));
  free_string_field (&(args_info->lon_orig));
  free_string_field (&(args_info->config_file_arg));
  free_string_field (&(args_info->config_file_orig));
  free_string_field (&(args_info->aov_orig));
  free_string_field (&(args_info->map_set_name_arg));
  free_string_field (&(args_info->map_set_name_orig));
  free_string_field (&(args_info->shading_scale_orig));
  free_string_field (&(args_info->light_direction_orig));
  free_string_field (&(args_info->airspace_wire_col_r_orig));
  free_string_field (&(args_info->airspace_wire_col_g_orig));
  free_string_field (&(args_info->airspace_wire_col_b_orig));
  free_string_field (&(args_info->airspace_wire_width_orig));
  free_string_field (&(args_info->airspace_file_arg));
  free_string_field (&(args_info->airspace_file_orig));
  free_string_field (&(args_info->airspace_limit_orig));
  free_string_field (&(args_info->eye_dist_orig));
  free_string_field (&(args_info->haze_density_orig));
  free_string_field (&(args_info->colormap_orig));
  free_string_field (&(args_info->colormap_sea_orig));
  free_string_field (&(args_info->colormap_min_orig));
  free_string_field (&(args_info->colormap_max_orig));
  free_string_field (&(args_info->sealevel_orig));
  free_string_field (&(args_info->sealevel2_orig));
  free_string_field (&(args_info->sealevel3_orig));
  free_string_field (&(args_info->ignore_elev_min_orig));
  free_string_field (&(args_info->ignore_elev_max_orig));
  free_string_field (&(args_info->scalez_orig));
  free_string_field (&(args_info->downscaling_orig));
  free_string_field (&(args_info->upscaling_orig));
  free_string_field (&(args_info->width_orig));
  free_string_field (&(args_info->height_orig));
  free_string_field (&(args_info->border_orig));
  free_string_field (&(args_info->border_lat_orig));
  free_string_field (&(args_info->border_lon_orig));
  free_string_field (&(args_info->offset_orig));
  free_string_field (&(args_info->airfield_elevation_orig));
  free_string_field (&(args_info->marker_pos_orig));
  free_string_field (&(args_info->marker_time_arg));
  free_string_field (&(args_info->marker_time_orig));
  free_string_field (&(args_info->marker_size_orig));
  free_string_field (&(args_info->text_arg));
  free_string_field (&(args_info->text_orig));
  free_string_field (&(args_info->text_size_orig));
  free_string_field (&(args_info->text_width_orig));
  free_string_field (&(args_info->lifts_arg));
  free_string_field (&(args_info->lifts_orig));
  free_string_field (&(args_info->lifts_info_mode_orig));
  free_string_field (&(args_info->waypoints_file_arg));
  free_string_field (&(args_info->waypoints_file_orig));
  free_string_field (&(args_info->waypoints_info_mode_orig));
  free_string_field (&(args_info->waypoints_offset_orig));
  free_string_field (&(args_info->waypoints_offset_spheres_orig));
  free_string_field (&(args_info->flighttrack_mode_orig));
  free_string_field (&(args_info->flighttrack_colormap_orig));
  free_string_field (&(args_info->flighttrack_linewidth_orig));
  free_string_field (&(args_info->marker_ahead_orig));
  free_string_field (&(args_info->marker_back_orig));
  free_string_field (&(args_info->cycles_orig));
  free_string_field (&(args_info->spinning_orig));
  free_string_field (&(args_info->parent_pid_orig));
  free_string_field (&(args_info->os_outfile_arg));
  free_string_field (&(args_info->os_outfile_orig));
  free_string_field (&(args_info->jpeg_quality_orig));
  free_string_field (&(args_info->image_format_arg));
  free_string_field (&(args_info->image_format_orig));
  free_string_field (&(args_info->save_path_arg));
  free_string_field (&(args_info->save_path_orig));
  free_string_field (&(args_info->basename_arg));
  free_string_field (&(args_info->basename_orig));
  free_string_field (&(args_info->clipping_far_orig));
  free_string_field (&(args_info->clipping_near_orig));
  free_string_field (&(args_info->init_lat_orig));
  free_string_field (&(args_info->init_lon_orig));
  free_string_field (&(args_info->init_alt_orig));
  free_string_field (&(args_info->init_heading_orig));
  free_string_field (&(args_info->init_dive_orig));
  free_string_field (&(args_info->init_ortho_lat_orig));
  free_string_field (&(args_info->init_ortho_lon_orig));
  free_string_field (&(args_info->init_ortho_width_orig));



  clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  FIX_UNUSED (values);
  if (arg) {
    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}


int
cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->verbose_given)
    write_into_file(outfile, "verbose", 0, 0 );
  if (args_info->quiet_given)
    write_into_file(outfile, "quiet", 0, 0 );
  if (args_info->query_gl_given)
    write_into_file(outfile, "query-gl", 0, 0 );
  if (args_info->check_given)
    write_into_file(outfile, "check", 0, 0 );
  if (args_info->compiler_given)
    write_into_file(outfile, "compiler", 0, 0 );
  if (args_info->debug_given)
    write_into_file(outfile, "debug", 0, 0 );
  if (args_info->igc_file_given)
    write_into_file(outfile, "igc-file", args_info->igc_file_orig, 0);
  if (args_info->gpsd_given)
    write_into_file(outfile, "gpsd", 0, 0 );
  if (args_info->gpsd_server_given)
    write_into_file(outfile, "gpsd-server", args_info->gpsd_server_orig, 0);
  if (args_info->gpsd_port_given)
    write_into_file(outfile, "gpsd-port", args_info->gpsd_port_orig, 0);
  if (args_info->gpsalt_given)
    write_into_file(outfile, "gpsalt", 0, 0 );
  if (args_info->baroalt_given)
    write_into_file(outfile, "baroalt", 0, 0 );
  if (args_info->use_all_fixes_given)
    write_into_file(outfile, "use-all-fixes", 0, 0 );
  if (args_info->lat_given)
    write_into_file(outfile, "lat", args_info->lat_orig, 0);
  if (args_info->lon_given)
    write_into_file(outfile, "lon", args_info->lon_orig, 0);
  if (args_info->get_elevation_given)
    write_into_file(outfile, "get-elevation", 0, 0 );
  if (args_info->config_file_given)
    write_into_file(outfile, "config-file", args_info->config_file_orig, 0);
  if (args_info->ortho_given)
    write_into_file(outfile, "ortho", 0, 0 );
  if (args_info->perspective_given)
    write_into_file(outfile, "perspective", 0, 0 );
  if (args_info->aov_given)
    write_into_file(outfile, "aov", args_info->aov_orig, 0);
  if (args_info->landscape_given)
    write_into_file(outfile, "landscape", 0, 0 );
  if (args_info->flat_given)
    write_into_file(outfile, "flat", 0, 0 );
  if (args_info->map_given)
    write_into_file(outfile, "map", 0, 0 );
  if (args_info->no_map_given)
    write_into_file(outfile, "no-map", 0, 0 );
  if (args_info->map_set_name_given)
    write_into_file(outfile, "map-set-name", args_info->map_set_name_orig, 0);
  if (args_info->modulate_given)
    write_into_file(outfile, "modulate", 0, 0 );
  if (args_info->no_modulate_given)
    write_into_file(outfile, "no-modulate", 0, 0 );
  if (args_info->maps_unlighted_given)
    write_into_file(outfile, "maps-unlighted", 0, 0 );
  if (args_info->maps_lighted_given)
    write_into_file(outfile, "maps-lighted", 0, 0 );
  if (args_info->no_lighting_given)
    write_into_file(outfile, "no-lighting", 0, 0 );
  if (args_info->terrain_shading_given)
    write_into_file(outfile, "terrain-shading", 0, 0 );
  if (args_info->shading_scale_given)
    write_into_file(outfile, "shading-scale", args_info->shading_scale_orig, 0);
  if (args_info->light_direction_given)
    write_into_file(outfile, "light-direction", args_info->light_direction_orig, 0);
  if (args_info->airspace_given)
    write_into_file(outfile, "airspace", 0, 0 );
  if (args_info->airspace_wire_given)
    write_into_file(outfile, "airspace-wire", 0, 0 );
  if (args_info->airspace_wire_col_r_given)
    write_into_file(outfile, "airspace-wire-col-r", args_info->airspace_wire_col_r_orig, 0);
  if (args_info->airspace_wire_col_g_given)
    write_into_file(outfile, "airspace-wire-col-g", args_info->airspace_wire_col_g_orig, 0);
  if (args_info->airspace_wire_col_b_given)
    write_into_file(outfile, "airspace-wire-col-b", args_info->airspace_wire_col_b_orig, 0);
  if (args_info->airspace_wire_width_given)
    write_into_file(outfile, "airspace-wire-width", args_info->airspace_wire_width_orig, 0);
  if (args_info->airspace_transparent_given)
    write_into_file(outfile, "airspace-transparent", 0, 0 );
  if (args_info->no_airspace_given)
    write_into_file(outfile, "no-airspace", 0, 0 );
  if (args_info->airspace_file_given)
    write_into_file(outfile, "airspace-file", args_info->airspace_file_orig, 0);
  if (args_info->airspace_limit_given)
    write_into_file(outfile, "airspace-limit", args_info->airspace_limit_orig, 0);
  if (args_info->wire_given)
    write_into_file(outfile, "wire", 0, 0 );
  if (args_info->filled_given)
    write_into_file(outfile, "filled", 0, 0 );
  if (args_info->grayscale_given)
    write_into_file(outfile, "grayscale", 0, 0 );
  if (args_info->color_given)
    write_into_file(outfile, "color", 0, 0 );
  if (args_info->stereo_given)
    write_into_file(outfile, "stereo", 0, 0 );
  if (args_info->no_stereo_given)
    write_into_file(outfile, "no-stereo", 0, 0 );
  if (args_info->stereo_rg_given)
    write_into_file(outfile, "stereo-rg", 0, 0 );
  if (args_info->no_stereo_rg_given)
    write_into_file(outfile, "no-stereo-rg", 0, 0 );
  if (args_info->stereo_rb_given)
    write_into_file(outfile, "stereo-rb", 0, 0 );
  if (args_info->no_stereo_rb_given)
    write_into_file(outfile, "no-stereo-rb", 0, 0 );
  if (args_info->stereo_hw_given)
    write_into_file(outfile, "stereo-hw", 0, 0 );
  if (args_info->no_stereo_hw_given)
    write_into_file(outfile, "no-stereo-hw", 0, 0 );
  if (args_info->inverse_stereo_given)
    write_into_file(outfile, "inverse-stereo", 0, 0 );
  if (args_info->no_inverse_stereo_given)
    write_into_file(outfile, "no-inverse-stereo", 0, 0 );
  if (args_info->eye_dist_given)
    write_into_file(outfile, "eye-dist", args_info->eye_dist_orig, 0);
  if (args_info->flat_shading_given)
    write_into_file(outfile, "flat-shading", 0, 0 );
  if (args_info->gouraud_shading_given)
    write_into_file(outfile, "gouraud-shading", 0, 0 );
  if (args_info->quads_given)
    write_into_file(outfile, "quads", 0, 0 );
  if (args_info->curtain_given)
    write_into_file(outfile, "curtain", 0, 0 );
  if (args_info->no_curtain_given)
    write_into_file(outfile, "no-curtain", 0, 0 );
  if (args_info->haze_given)
    write_into_file(outfile, "haze", 0, 0 );
  if (args_info->no_haze_given)
    write_into_file(outfile, "no-haze", 0, 0 );
  if (args_info->haze_density_given)
    write_into_file(outfile, "haze-density", args_info->haze_density_orig, 0);
  if (args_info->colormap_given)
    write_into_file(outfile, "colormap", args_info->colormap_orig, 0);
  if (args_info->colormap_sea_given)
    write_into_file(outfile, "colormap-sea", args_info->colormap_sea_orig, 0);
  if (args_info->colormap_min_given)
    write_into_file(outfile, "colormap-min", args_info->colormap_min_orig, 0);
  if (args_info->colormap_max_given)
    write_into_file(outfile, "colormap-max", args_info->colormap_max_orig, 0);
  if (args_info->sealevel_given)
    write_into_file(outfile, "sealevel", args_info->sealevel_orig, 0);
  if (args_info->sealevel2_given)
    write_into_file(outfile, "sealevel2", args_info->sealevel2_orig, 0);
  if (args_info->sealevel3_given)
    write_into_file(outfile, "sealevel3", args_info->sealevel3_orig, 0);
  if (args_info->ignore_elev_min_given)
    write_into_file(outfile, "ignore-elev-min", args_info->ignore_elev_min_orig, 0);
  if (args_info->ignore_elev_max_given)
    write_into_file(outfile, "ignore-elev-max", args_info->ignore_elev_max_orig, 0);
  if (args_info->scalez_given)
    write_into_file(outfile, "scalez", args_info->scalez_orig, 0);
  if (args_info->downscaling_given)
    write_into_file(outfile, "downscaling", args_info->downscaling_orig, 0);
  if (args_info->upscaling_given)
    write_into_file(outfile, "upscaling", args_info->upscaling_orig, 0);
  if (args_info->fullscreen_given)
    write_into_file(outfile, "fullscreen", 0, 0 );
  if (args_info->window_given)
    write_into_file(outfile, "window", 0, 0 );
  if (args_info->width_given)
    write_into_file(outfile, "width", args_info->width_orig, 0);
  if (args_info->height_given)
    write_into_file(outfile, "height", args_info->height_orig, 0);
  if (args_info->border_given)
    write_into_file(outfile, "border", args_info->border_orig, 0);
  if (args_info->border_lat_given)
    write_into_file(outfile, "border-lat", args_info->border_lat_orig, 0);
  if (args_info->border_lon_given)
    write_into_file(outfile, "border-lon", args_info->border_lon_orig, 0);
  if (args_info->offset_given)
    write_into_file(outfile, "offset", args_info->offset_orig, 0);
  if (args_info->airfield_elevation_given)
    write_into_file(outfile, "airfield-elevation", args_info->airfield_elevation_orig, 0);
  if (args_info->marker_pos_given)
    write_into_file(outfile, "marker-pos", args_info->marker_pos_orig, 0);
  if (args_info->marker_time_given)
    write_into_file(outfile, "marker-time", args_info->marker_time_orig, 0);
  if (args_info->marker_given)
    write_into_file(outfile, "marker", 0, 0 );
  if (args_info->marker_size_given)
    write_into_file(outfile, "marker-size", args_info->marker_size_orig, 0);
  if (args_info->no_marker_given)
    write_into_file(outfile, "no-marker", 0, 0 );
  if (args_info->info_given)
    write_into_file(outfile, "info", 0, 0 );
  if (args_info->no_info_given)
    write_into_file(outfile, "no-info", 0, 0 );
  if (args_info->text_given)
    write_into_file(outfile, "text", args_info->text_orig, 0);
  if (args_info->no_position_info_given)
    write_into_file(outfile, "no-position-info", 0, 0 );
  if (args_info->no_marker_pos_info_given)
    write_into_file(outfile, "no-marker-pos-info", 0, 0 );
  if (args_info->text_size_given)
    write_into_file(outfile, "text-size", args_info->text_size_orig, 0);
  if (args_info->text_width_given)
    write_into_file(outfile, "text-width", args_info->text_width_orig, 0);
  if (args_info->lifts_given)
    write_into_file(outfile, "lifts", args_info->lifts_orig, 0);
  if (args_info->lifts_info_mode_given)
    write_into_file(outfile, "lifts-info-mode", args_info->lifts_info_mode_orig, 0);
  if (args_info->waypoints_file_given)
    write_into_file(outfile, "waypoints-file", args_info->waypoints_file_orig, 0);
  if (args_info->waypoints_given)
    write_into_file(outfile, "waypoints", 0, 0 );
  if (args_info->no_waypoints_given)
    write_into_file(outfile, "no-waypoints", 0, 0 );
  if (args_info->waypoints_info_mode_given)
    write_into_file(outfile, "waypoints-info-mode", args_info->waypoints_info_mode_orig, 0);
  if (args_info->waypoints_offset_given)
    write_into_file(outfile, "waypoints-offset", args_info->waypoints_offset_orig, 0);
  if (args_info->waypoints_offset_spheres_given)
    write_into_file(outfile, "waypoints-offset-spheres", args_info->waypoints_offset_spheres_orig, 0);
  if (args_info->flighttrack_mode_given)
    write_into_file(outfile, "flighttrack-mode", args_info->flighttrack_mode_orig, 0);
  if (args_info->flighttrack_colormap_given)
    write_into_file(outfile, "flighttrack-colormap", args_info->flighttrack_colormap_orig, 0);
  if (args_info->flighttrack_linewidth_given)
    write_into_file(outfile, "flighttrack-linewidth", args_info->flighttrack_linewidth_orig, 0);
  if (args_info->follow_given)
    write_into_file(outfile, "follow", 0, 0 );
  if (args_info->no_follow_given)
    write_into_file(outfile, "no-follow", 0, 0 );
  if (args_info->marker_range_given)
    write_into_file(outfile, "marker-range", 0, 0 );
  if (args_info->no_marker_range_given)
    write_into_file(outfile, "no-marker-range", 0, 0 );
  if (args_info->marker_ahead_given)
    write_into_file(outfile, "marker-ahead", args_info->marker_ahead_orig, 0);
  if (args_info->marker_back_given)
    write_into_file(outfile, "marker-back", args_info->marker_back_orig, 0);
  if (args_info->movie_given)
    write_into_file(outfile, "movie", 0, 0 );
  if (args_info->cycles_given)
    write_into_file(outfile, "cycles", args_info->cycles_orig, 0);
  if (args_info->spinning_given)
    write_into_file(outfile, "spinning", args_info->spinning_orig, 0);
  if (args_info->smooth_mouse_given)
    write_into_file(outfile, "smooth-mouse", 0, 0 );
  if (args_info->parent_pid_given)
    write_into_file(outfile, "parent-pid", args_info->parent_pid_orig, 0);
  if (args_info->compression_given)
    write_into_file(outfile, "compression", 0, 0 );
  if (args_info->no_compression_given)
    write_into_file(outfile, "no-compression", 0, 0 );
  if (args_info->offscreen_given)
    write_into_file(outfile, "offscreen", 0, 0 );
  if (args_info->osmesa_given)
    write_into_file(outfile, "osmesa", 0, 0 );
  if (args_info->os_outfile_given)
    write_into_file(outfile, "os-outfile", args_info->os_outfile_orig, 0);
  if (args_info->jpeg_quality_given)
    write_into_file(outfile, "jpeg-quality", args_info->jpeg_quality_orig, 0);
  if (args_info->image_format_given)
    write_into_file(outfile, "image-format", args_info->image_format_orig, 0);
  if (args_info->save_path_given)
    write_into_file(outfile, "save-path", args_info->save_path_orig, 0);
  if (args_info->basename_given)
    write_into_file(outfile, "basename", args_info->basename_orig, 0);
  if (args_info->clipping_far_given)
    write_into_file(outfile, "clipping-far", args_info->clipping_far_orig, 0);
  if (args_info->clipping_near_given)
    write_into_file(outfile, "clipping-near", args_info->clipping_near_orig, 0);
  if (args_info->init_lat_given)
    write_into_file(outfile, "init-lat", args_info->init_lat_orig, 0);
  if (args_info->init_lon_given)
    write_into_file(outfile, "init-lon", args_info->init_lon_orig, 0);
  if (args_info->init_alt_given)
    write_into_file(outfile, "init-alt", args_info->init_alt_orig, 0);
  if (args_info->init_heading_given)
    write_into_file(outfile, "init-heading", args_info->init_heading_orig, 0);
  if (args_info->init_dive_given)
    write_into_file(outfile, "init-dive", args_info->init_dive_orig, 0);
  if (args_info->init_pos_N_given)
    write_into_file(outfile, "init-pos-N", 0, 0 );
  if (args_info->init_pos_E_given)
    write_into_file(outfile, "init-pos-E", 0, 0 );
  if (args_info->init_pos_S_given)
    write_into_file(outfile, "init-pos-S", 0, 0 );
  if (args_info->init_pos_W_given)
    write_into_file(outfile, "init-pos-W", 0, 0 );
  if (args_info->init_pos_NE_given)
    write_into_file(outfile, "init-pos-NE", 0, 0 );
  if (args_info->init_pos_SE_given)
    write_into_file(outfile, "init-pos-SE", 0, 0 );
  if (args_info->init_pos_SW_given)
    write_into_file(outfile, "init-pos-SW", 0, 0 );
  if (args_info->init_pos_NW_given)
    write_into_file(outfile, "init-pos-NW", 0, 0 );
  if (args_info->init_pos_center_given)
    write_into_file(outfile, "init-pos-center", 0, 0 );
  if (args_info->init_ortho_lat_given)
    write_into_file(outfile, "init-ortho-lat", args_info->init_ortho_lat_orig, 0);
  if (args_info->init_ortho_lon_given)
    write_into_file(outfile, "init-ortho-lon", args_info->init_ortho_lon_orig, 0);
  if (args_info->init_ortho_width_given)
    write_into_file(outfile, "init-ortho-width", args_info->init_ortho_width_orig, 0);
  if (args_info->projection_cyl_platt_given)
    write_into_file(outfile, "projection-cyl-platt", 0, 0 );
  if (args_info->projection_cyl_no1_given)
    write_into_file(outfile, "projection-cyl-no1", 0, 0 );
  if (args_info->projection_pseudo_cyl_no1_given)
    write_into_file(outfile, "projection-pseudo-cyl-no1", 0, 0 );
  if (args_info->projection_cyl_mercator_given)
    write_into_file(outfile, "projection-cyl-mercator", 0, 0 );


  i = EXIT_SUCCESS;
  return i;
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }

  return result;
}

int
cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct cmdline_parser_params params;

  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }

  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  FIX_UNUSED (args_info);
  FIX_UNUSED (prog_name);
  return EXIT_SUCCESS;
}

/*
 * Extracted from the glibc source tree, version 2.3.6
 *
 * Licensed under the GPL as per the whole glibc source tree.
 *
 * This file was modified so that getopt_long can be called
 * many times without risking previous memory to be spoiled.
 *
 * Modified by Andre Noll and Lorenzo Bettini for use in
 * GNU gengetopt generated files.
 *
 */

/*
 * we must include anything we need since this file is not thought to be
 * inserted in a file already using getopt.h
 *
 * Lorenzo
 */

struct option
{
  const char *name;
  /* has_arg can't be an enum because some compilers complain about
     type mismatches in all the code that assumes it is an int.  */
  int has_arg;
  int *flag;
  int val;
};

/* This version of `getopt' appears to the caller like standard Unix `getopt'
   but it behaves differently for the user, since it allows the user
   to intersperse the options with the other arguments.

   As `getopt' works, it permutes the elements of ARGV so that,
   when it is done, all the options precede everything else.  Thus
   all application programs are extended to handle flexible argument order.
*/
/*
   If the field `flag' is not NULL, it points to a variable that is set
   to the value given in the field `val' when the option is found, but
   left unchanged if the option is not found.

   To have a long-named option do something other than set an `int' to
   a compiled-in constant, such as set a value from `custom_optarg', set the
   option's `flag' field to zero and its `val' field to a nonzero
   value (the equivalent single-letter option character, if there is
   one).  For long options that have a zero `flag' field, `getopt'
   returns the contents of the `val' field.  */

/* Names for the values of the `has_arg' field of `struct option'.  */
#ifndef no_argument
#define no_argument		0
#endif

#ifndef required_argument
#define required_argument	1
#endif

#ifndef optional_argument
#define optional_argument	2
#endif

struct custom_getopt_data {
	/*
	 * These have exactly the same meaning as the corresponding global variables,
	 * except that they are used for the reentrant versions of getopt.
	 */
	int custom_optind;
	int custom_opterr;
	int custom_optopt;
	char *custom_optarg;

	/* True if the internal members have been initialized.  */
	int initialized;

	/*
	 * The next char to be scanned in the option-element in which the last option
	 * character we returned was found.  This allows us to pick up the scan where
	 * we left off.  If this is zero, or a null string, it means resume the scan by
	 * advancing to the next ARGV-element.
	 */
	char *nextchar;

	/*
	 * Describe the part of ARGV that contains non-options that have been skipped.
	 * `first_nonopt' is the index in ARGV of the first of them; `last_nonopt' is
	 * the index after the last of them.
	 */
	int first_nonopt;
	int last_nonopt;
};

/*
 * the variables optarg, optind, opterr and optopt are renamed with
 * the custom_ prefix so that they don't interfere with getopt ones.
 *
 * Moreover they're static so they are visible only from within the
 * file where this very file will be included.
 */

/*
 * For communication from `custom_getopt' to the caller.  When `custom_getopt' finds an
 * option that takes an argument, the argument value is returned here.
 */
static char *custom_optarg;

/*
 * Index in ARGV of the next element to be scanned.  This is used for
 * communication to and from the caller and for communication between
 * successive calls to `custom_getopt'.
 *
 * On entry to `custom_getopt', 1 means this is the first call; initialize.
 *
 * When `custom_getopt' returns -1, this is the index of the first of the non-option
 * elements that the caller should itself scan.
 *
 * Otherwise, `custom_optind' communicates from one call to the next how much of ARGV
 * has been scanned so far.
 *
 * 1003.2 says this must be 1 before any call.
 */
static int custom_optind = 1;

/*
 * Callers store zero here to inhibit the error message for unrecognized
 * options.
 */
static int custom_opterr = 1;

/*
 * Set to an option character which was unrecognized.  This must be initialized
 * on some systems to avoid linking in the system's own getopt implementation.
 */
static int custom_optopt = '?';

/*
 * Exchange two adjacent subsequences of ARGV.  One subsequence is elements
 * [first_nonopt,last_nonopt) which contains all the non-options that have been
 * skipped so far.  The other is elements [last_nonopt,custom_optind), which contains
 * all the options processed since those non-options were skipped.
 * `first_nonopt' and `last_nonopt' are relocated so that they describe the new
 * indices of the non-options in ARGV after they are moved.
 */
static void exchange(char **argv, struct custom_getopt_data *d)
{
	int bottom = d->first_nonopt;
	int middle = d->last_nonopt;
	int top = d->custom_optind;
	char *tem;

	/*
	 * Exchange the shorter segment with the far end of the longer segment.
	 * That puts the shorter segment into the right place.  It leaves the
	 * longer segment in the right place overall, but it consists of two
	 * parts that need to be swapped next.
	 */
	while (top > middle && middle > bottom) {
		if (top - middle > middle - bottom) {
			/* Bottom segment is the short one.  */
			int len = middle - bottom;
			int i;

			/* Swap it with the top part of the top segment.  */
			for (i = 0; i < len; i++) {
				tem = argv[bottom + i];
				argv[bottom + i] =
					argv[top - (middle - bottom) + i];
				argv[top - (middle - bottom) + i] = tem;
			}
			/* Exclude the moved bottom segment from further swapping.  */
			top -= len;
		} else {
			/* Top segment is the short one.  */
			int len = top - middle;
			int i;

			/* Swap it with the bottom part of the bottom segment.  */
			for (i = 0; i < len; i++) {
				tem = argv[bottom + i];
				argv[bottom + i] = argv[middle + i];
				argv[middle + i] = tem;
			}
			/* Exclude the moved top segment from further swapping.  */
			bottom += len;
		}
	}
	/* Update records for the slots the non-options now occupy.  */
	d->first_nonopt += (d->custom_optind - d->last_nonopt);
	d->last_nonopt = d->custom_optind;
}

/* Initialize the internal data when the first call is made.  */
static void custom_getopt_initialize(struct custom_getopt_data *d)
{
	/*
	 * Start processing options with ARGV-element 1 (since ARGV-element 0
	 * is the program name); the sequence of previously skipped non-option
	 * ARGV-elements is empty.
	 */
	d->first_nonopt = d->last_nonopt = d->custom_optind;
	d->nextchar = NULL;
	d->initialized = 1;
}

#define NONOPTION_P (argv[d->custom_optind][0] != '-' || argv[d->custom_optind][1] == '\0')

/* return: zero: continue, nonzero: return given value to user */
static int shuffle_argv(int argc, char *const *argv,const struct option *longopts,
	struct custom_getopt_data *d)
{
	/*
	 * Give FIRST_NONOPT & LAST_NONOPT rational values if CUSTOM_OPTIND has been
	 * moved back by the user (who may also have changed the arguments).
	 */
	if (d->last_nonopt > d->custom_optind)
		d->last_nonopt = d->custom_optind;
	if (d->first_nonopt > d->custom_optind)
		d->first_nonopt = d->custom_optind;
	/*
	 * If we have just processed some options following some
	 * non-options, exchange them so that the options come first.
	 */
	if (d->first_nonopt != d->last_nonopt &&
			d->last_nonopt != d->custom_optind)
		exchange((char **) argv, d);
	else if (d->last_nonopt != d->custom_optind)
		d->first_nonopt = d->custom_optind;
	/*
	 * Skip any additional non-options and extend the range of
	 * non-options previously skipped.
	 */
	while (d->custom_optind < argc && NONOPTION_P)
		d->custom_optind++;
	d->last_nonopt = d->custom_optind;
	/*
	 * The special ARGV-element `--' means premature end of options.  Skip
	 * it like a null option, then exchange with previous non-options as if
	 * it were an option, then skip everything else like a non-option.
	 */
	if (d->custom_optind != argc && !strcmp(argv[d->custom_optind], "--")) {
		d->custom_optind++;
		if (d->first_nonopt != d->last_nonopt
				&& d->last_nonopt != d->custom_optind)
			exchange((char **) argv, d);
		else if (d->first_nonopt == d->last_nonopt)
			d->first_nonopt = d->custom_optind;
		d->last_nonopt = argc;
		d->custom_optind = argc;
	}
	/*
	 * If we have done all the ARGV-elements, stop the scan and back over
	 * any non-options that we skipped and permuted.
	 */
	if (d->custom_optind == argc) {
		/*
		 * Set the next-arg-index to point at the non-options that we
		 * previously skipped, so the caller will digest them.
		 */
		if (d->first_nonopt != d->last_nonopt)
			d->custom_optind = d->first_nonopt;
		return -1;
	}
	/*
	 * If we have come to a non-option and did not permute it, either stop
	 * the scan or describe it to the caller and pass it by.
	 */
	if (NONOPTION_P) {
		d->custom_optarg = argv[d->custom_optind++];
		return 1;
	}
	/*
	 * We have found another option-ARGV-element. Skip the initial
	 * punctuation.
	 */
	d->nextchar = (argv[d->custom_optind] + 1 + (longopts != NULL && argv[d->custom_optind][1] == '-'));
	return 0;
}

/*
 * Check whether the ARGV-element is a long option.
 *
 * If there's a long option "fubar" and the ARGV-element is "-fu", consider
 * that an abbreviation of the long option, just like "--fu", and not "-f" with
 * arg "u".
 *
 * This distinction seems to be the most useful approach.
 *
 */
static int check_long_opt(int argc, char *const *argv, const char *optstring,
		const struct option *longopts, int *longind,
		int print_errors, struct custom_getopt_data *d)
{
	char *nameend;
	const struct option *p;
	const struct option *pfound = NULL;
	int exact = 0;
	int ambig = 0;
	int indfound = -1;
	int option_index;

	for (nameend = d->nextchar; *nameend && *nameend != '='; nameend++)
		/* Do nothing.  */ ;

	/* Test all long options for either exact match or abbreviated matches */
	for (p = longopts, option_index = 0; p->name; p++, option_index++)
		if (!strncmp(p->name, d->nextchar, nameend - d->nextchar)) {
			if ((unsigned int) (nameend - d->nextchar)
					== (unsigned int) strlen(p->name)) {
				/* Exact match found.  */
				pfound = p;
				indfound = option_index;
				exact = 1;
				break;
			} else if (pfound == NULL) {
				/* First nonexact match found.  */
				pfound = p;
				indfound = option_index;
			} else if (pfound->has_arg != p->has_arg
					|| pfound->flag != p->flag
					|| pfound->val != p->val)
				/* Second or later nonexact match found.  */
				ambig = 1;
		}
	if (ambig && !exact) {
		if (print_errors) {
			fprintf(stderr,
				"%s: option `%s' is ambiguous\n",
				argv[0], argv[d->custom_optind]);
		}
		d->nextchar += strlen(d->nextchar);
		d->custom_optind++;
		d->custom_optopt = 0;
		return '?';
	}
	if (pfound) {
		option_index = indfound;
		d->custom_optind++;
		if (*nameend) {
			if (pfound->has_arg != no_argument)
				d->custom_optarg = nameend + 1;
			else {
				if (print_errors) {
					if (argv[d->custom_optind - 1][1] == '-') {
						/* --option */
						fprintf(stderr, "%s: option `--%s' doesn't allow an argument\n",
							argv[0], pfound->name);
					} else {
						/* +option or -option */
						fprintf(stderr, "%s: option `%c%s' doesn't allow an argument\n",
							argv[0], argv[d->custom_optind - 1][0], pfound->name);
					}

				}
				d->nextchar += strlen(d->nextchar);
				d->custom_optopt = pfound->val;
				return '?';
			}
		} else if (pfound->has_arg == required_argument) {
			if (d->custom_optind < argc)
				d->custom_optarg = argv[d->custom_optind++];
			else {
				if (print_errors) {
					fprintf(stderr,
						"%s: option `%s' requires an argument\n",
						argv[0],
						argv[d->custom_optind - 1]);
				}
				d->nextchar += strlen(d->nextchar);
				d->custom_optopt = pfound->val;
				return optstring[0] == ':' ? ':' : '?';
			}
		}
		d->nextchar += strlen(d->nextchar);
		if (longind != NULL)
			*longind = option_index;
		if (pfound->flag) {
			*(pfound->flag) = pfound->val;
			return 0;
		}
		return pfound->val;
	}
	/*
	 * Can't find it as a long option.  If this is not getopt_long_only, or
	 * the option starts with '--' or is not a valid short option, then
	 * it's an error.  Otherwise interpret it as a short option.
	 */
	if (print_errors) {
		if (argv[d->custom_optind][1] == '-') {
			/* --option */
			fprintf(stderr,
				"%s: unrecognized option `--%s'\n",
				argv[0], d->nextchar);
		} else {
			/* +option or -option */
			fprintf(stderr,
				"%s: unrecognized option `%c%s'\n",
				argv[0], argv[d->custom_optind][0],
				d->nextchar);
		}
	}
	d->nextchar = (char *) "";
	d->custom_optind++;
	d->custom_optopt = 0;
	return '?';
}

static int check_short_opt(int argc, char *const *argv, const char *optstring,
		int print_errors, struct custom_getopt_data *d)
{
	char c = *d->nextchar++;
	const char *temp = strchr(optstring, c);

	/* Increment `custom_optind' when we start to process its last character.  */
	if (*d->nextchar == '\0')
		++d->custom_optind;
	if (!temp || c == ':') {
		if (print_errors)
			fprintf(stderr, "%s: invalid option -- %c\n", argv[0], c);

		d->custom_optopt = c;
		return '?';
	}
	if (temp[1] == ':') {
		if (temp[2] == ':') {
			/* This is an option that accepts an argument optionally.  */
			if (*d->nextchar != '\0') {
				d->custom_optarg = d->nextchar;
				d->custom_optind++;
			} else
				d->custom_optarg = NULL;
			d->nextchar = NULL;
		} else {
			/* This is an option that requires an argument.  */
			if (*d->nextchar != '\0') {
				d->custom_optarg = d->nextchar;
				/*
				 * If we end this ARGV-element by taking the
				 * rest as an arg, we must advance to the next
				 * element now.
				 */
				d->custom_optind++;
			} else if (d->custom_optind == argc) {
				if (print_errors) {
					fprintf(stderr,
						"%s: option requires an argument -- %c\n",
						argv[0], c);
				}
				d->custom_optopt = c;
				if (optstring[0] == ':')
					c = ':';
				else
					c = '?';
			} else
				/*
				 * We already incremented `custom_optind' once;
				 * increment it again when taking next ARGV-elt
				 * as argument.
				 */
				d->custom_optarg = argv[d->custom_optind++];
			d->nextchar = NULL;
		}
	}
	return c;
}

/*
 * Scan elements of ARGV for option characters given in OPTSTRING.
 *
 * If an element of ARGV starts with '-', and is not exactly "-" or "--",
 * then it is an option element.  The characters of this element
 * (aside from the initial '-') are option characters.  If `getopt'
 * is called repeatedly, it returns successively each of the option characters
 * from each of the option elements.
 *
 * If `getopt' finds another option character, it returns that character,
 * updating `custom_optind' and `nextchar' so that the next call to `getopt' can
 * resume the scan with the following option character or ARGV-element.
 *
 * If there are no more option characters, `getopt' returns -1.
 * Then `custom_optind' is the index in ARGV of the first ARGV-element
 * that is not an option.  (The ARGV-elements have been permuted
 * so that those that are not options now come last.)
 *
 * OPTSTRING is a string containing the legitimate option characters.
 * If an option character is seen that is not listed in OPTSTRING,
 * return '?' after printing an error message.  If you set `custom_opterr' to
 * zero, the error message is suppressed but we still return '?'.
 *
 * If a char in OPTSTRING is followed by a colon, that means it wants an arg,
 * so the following text in the same ARGV-element, or the text of the following
 * ARGV-element, is returned in `custom_optarg'.  Two colons mean an option that
 * wants an optional arg; if there is text in the current ARGV-element,
 * it is returned in `custom_optarg', otherwise `custom_optarg' is set to zero.
 *
 * If OPTSTRING starts with `-' or `+', it requests different methods of
 * handling the non-option ARGV-elements.
 * See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
 *
 * Long-named options begin with `--' instead of `-'.
 * Their names may be abbreviated as long as the abbreviation is unique
 * or is an exact match for some defined option.  If they have an
 * argument, it follows the option name in the same ARGV-element, separated
 * from the option name by a `=', or else the in next ARGV-element.
 * When `getopt' finds a long-named option, it returns 0 if that option's
 * `flag' field is nonzero, the value of the option's `val' field
 * if the `flag' field is zero.
 *
 * The elements of ARGV aren't really const, because we permute them.
 * But we pretend they're const in the prototype to be compatible
 * with other systems.
 *
 * LONGOPTS is a vector of `struct option' terminated by an
 * element containing a name which is zero.
 *
 * LONGIND returns the index in LONGOPT of the long-named option found.
 * It is only valid when a long-named option has been found by the most
 * recent call.
 *
 * Return the option character from OPTS just read.  Return -1 when there are
 * no more options.  For unrecognized options, or options missing arguments,
 * `custom_optopt' is set to the option letter, and '?' is returned.
 *
 * The OPTS string is a list of characters which are recognized option letters,
 * optionally followed by colons, specifying that that letter takes an
 * argument, to be placed in `custom_optarg'.
 *
 * If a letter in OPTS is followed by two colons, its argument is optional.
 * This behavior is specific to the GNU `getopt'.
 *
 * The argument `--' causes premature termination of argument scanning,
 * explicitly telling `getopt' that there are no more options.  If OPTS begins
 * with `--', then non-option arguments are treated as arguments to the option
 * '\0'.  This behavior is specific to the GNU `getopt'.
 */

static int getopt_internal_r(int argc, char *const *argv, const char *optstring,
		const struct option *longopts, int *longind,
		struct custom_getopt_data *d)
{
	int ret, print_errors = d->custom_opterr;

	if (optstring[0] == ':')
		print_errors = 0;
	if (argc < 1)
		return -1;
	d->custom_optarg = NULL;

	/*
	 * This is a big difference with GNU getopt, since optind == 0
	 * means initialization while here 1 means first call.
	 */
	if (d->custom_optind == 0 || !d->initialized) {
		if (d->custom_optind == 0)
			d->custom_optind = 1;	/* Don't scan ARGV[0], the program name.  */
		custom_getopt_initialize(d);
	}
	if (d->nextchar == NULL || *d->nextchar == '\0') {
		ret = shuffle_argv(argc, argv, longopts, d);
		if (ret)
			return ret;
	}
	if (longopts && (argv[d->custom_optind][1] == '-' ))
		return check_long_opt(argc, argv, optstring, longopts,
			longind, print_errors, d);
	return check_short_opt(argc, argv, optstring, print_errors, d);
}

static int custom_getopt_internal(int argc, char *const *argv, const char *optstring,
	const struct option *longopts, int *longind)
{
	int result;
	/* Keep a global copy of all internal members of d */
	static struct custom_getopt_data d;

	d.custom_optind = custom_optind;
	d.custom_opterr = custom_opterr;
	result = getopt_internal_r(argc, argv, optstring, longopts,
		longind, &d);
	custom_optind = d.custom_optind;
	custom_optarg = d.custom_optarg;
	custom_optopt = d.custom_optopt;
	return result;
}

static int custom_getopt_long (int argc, char *const *argv, const char *options,
	const struct option *long_options, int *opt_index)
{
	return custom_getopt_internal(argc, argv, options, long_options,
		opt_index);
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given,
               char *value, const char *possible_values[],
               const char *default_value,
               cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n",
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n",
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  FIX_UNUSED (default_value);

  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_FLOAT:
    if (val) *((float *)field) = (float)strtod (val, &stop_char);
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
  case ARG_FLOAT:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}


int
cmdline_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error_occurred = 0;
  struct gengetopt_args_info local_args_info;

  int override;
  int initialize;
  int check_required;
  int check_ambiguity;

  char *optarg;
  int optind;
  int opterr;
  int optopt;

  package_name = argv[0];

  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "verbose",	0, NULL, 'v' },
        { "quiet",	0, NULL, 0 },
        { "query-gl",	0, NULL, 'q' },
        { "check",	0, NULL, 0 },
        { "compiler",	0, NULL, 0 },
        { "debug",	0, NULL, 0 },
        { "igc-file",	1, NULL, 'i' },
        { "gpsd",	0, NULL, 0 },
        { "gpsd-server",	1, NULL, 0 },
        { "gpsd-port",	1, NULL, 0 },
        { "gpsalt",	0, NULL, 'g' },
        { "baroalt",	0, NULL, 'b' },
        { "use-all-fixes",	0, NULL, 0 },
        { "lat",	1, NULL, 0 },
        { "lon",	1, NULL, 0 },
        { "get-elevation",	0, NULL, 0 },
        { "config-file",	1, NULL, 'c' },
        { "ortho",	0, NULL, 'o' },
        { "perspective",	0, NULL, 0 },
        { "aov",	1, NULL, 0 },
        { "landscape",	0, NULL, 'l' },
        { "flat",	0, NULL, 'f' },
        { "map",	0, NULL, 'm' },
        { "no-map",	0, NULL, 0 },
        { "map-set-name",	1, NULL, 0 },
        { "modulate",	0, NULL, 0 },
        { "no-modulate",	0, NULL, 0 },
        { "maps-unlighted",	0, NULL, 0 },
        { "maps-lighted",	0, NULL, 0 },
        { "no-lighting",	0, NULL, 0 },
        { "terrain-shading",	0, NULL, 0 },
        { "shading-scale",	1, NULL, 0 },
        { "light-direction",	1, NULL, 0 },
        { "airspace",	0, NULL, 'a' },
        { "airspace-wire",	0, NULL, 0 },
        { "airspace-wire-col-r",	1, NULL, 0 },
        { "airspace-wire-col-g",	1, NULL, 0 },
        { "airspace-wire-col-b",	1, NULL, 0 },
        { "airspace-wire-width",	1, NULL, 0 },
        { "airspace-transparent",	0, NULL, 0 },
        { "no-airspace",	0, NULL, 0 },
        { "airspace-file",	1, NULL, 0 },
        { "airspace-limit",	1, NULL, 0 },
        { "wire",	0, NULL, 'w' },
        { "filled",	0, NULL, 0 },
        { "grayscale",	0, NULL, 0 },
        { "color",	0, NULL, 0 },
        { "stereo",	0, NULL, 0 },
        { "no-stereo",	0, NULL, 0 },
        { "stereo-rg",	0, NULL, 0 },
        { "no-stereo-rg",	0, NULL, 0 },
        { "stereo-rb",	0, NULL, 0 },
        { "no-stereo-rb",	0, NULL, 0 },
        { "stereo-hw",	0, NULL, 0 },
        { "no-stereo-hw",	0, NULL, 0 },
        { "inverse-stereo",	0, NULL, 0 },
        { "no-inverse-stereo",	0, NULL, 0 },
        { "eye-dist",	1, NULL, 0 },
        { "flat-shading",	0, NULL, 0 },
        { "gouraud-shading",	0, NULL, 0 },
        { "quads",	0, NULL, 0 },
        { "curtain",	0, NULL, 0 },
        { "no-curtain",	0, NULL, 0 },
        { "haze",	0, NULL, 0 },
        { "no-haze",	0, NULL, 0 },
        { "haze-density",	1, NULL, 0 },
        { "colormap",	1, NULL, 0 },
        { "colormap-sea",	1, NULL, 0 },
        { "colormap-min",	1, NULL, 0 },
        { "colormap-max",	1, NULL, 0 },
        { "sealevel",	1, NULL, 0 },
        { "sealevel2",	1, NULL, 0 },
        { "sealevel3",	1, NULL, 0 },
        { "ignore-elev-min",	1, NULL, 0 },
        { "ignore-elev-max",	1, NULL, 0 },
        { "scalez",	1, NULL, 's' },
        { "downscaling",	1, NULL, 'd' },
        { "upscaling",	1, NULL, 0 },
        { "fullscreen",	0, NULL, 0 },
        { "window",	0, NULL, 0 },
        { "width",	1, NULL, 0 },
        { "height",	1, NULL, 0 },
        { "border",	1, NULL, 0 },
        { "border-lat",	1, NULL, 0 },
        { "border-lon",	1, NULL, 0 },
        { "offset",	1, NULL, 0 },
        { "airfield-elevation",	1, NULL, 'e' },
        { "marker-pos",	1, NULL, 0 },
        { "marker-time",	1, NULL, 0 },
        { "marker",	0, NULL, 0 },
        { "marker-size",	1, NULL, 0 },
        { "no-marker",	0, NULL, 0 },
        { "info",	0, NULL, 0 },
        { "no-info",	0, NULL, 0 },
        { "text",	1, NULL, 0 },
        { "no-position-info",	0, NULL, 0 },
        { "no-marker-pos-info",	0, NULL, 0 },
        { "text-size",	1, NULL, 0 },
        { "text-width",	1, NULL, 0 },
        { "lifts",	1, NULL, 0 },
        { "lifts-info-mode",	1, NULL, 0 },
        { "waypoints-file",	1, NULL, 0 },
        { "waypoints",	0, NULL, 0 },
        { "no-waypoints",	0, NULL, 0 },
        { "waypoints-info-mode",	1, NULL, 0 },
        { "waypoints-offset",	1, NULL, 0 },
        { "waypoints-offset-spheres",	1, NULL, 0 },
        { "flighttrack-mode",	1, NULL, 0 },
        { "flighttrack-colormap",	1, NULL, 0 },
        { "flighttrack-linewidth",	1, NULL, 0 },
        { "follow",	0, NULL, 0 },
        { "no-follow",	0, NULL, 0 },
        { "marker-range",	0, NULL, 0 },
        { "no-marker-range",	0, NULL, 0 },
        { "marker-ahead",	1, NULL, 0 },
        { "marker-back",	1, NULL, 0 },
        { "movie",	0, NULL, 0 },
        { "cycles",	1, NULL, 0 },
        { "spinning",	1, NULL, 0 },
        { "smooth-mouse",	0, NULL, 0 },
        { "parent-pid",	1, NULL, 0 },
        { "compression",	0, NULL, 0 },
        { "no-compression",	0, NULL, 0 },
        { "offscreen",	0, NULL, 0 },
        { "osmesa",	0, NULL, 0 },
        { "os-outfile",	1, NULL, 0 },
        { "jpeg-quality",	1, NULL, 0 },
        { "image-format",	1, NULL, 0 },
        { "save-path",	1, NULL, 0 },
        { "basename",	1, NULL, 0 },
        { "clipping-far",	1, NULL, 0 },
        { "clipping-near",	1, NULL, 0 },
        { "init-lat",	1, NULL, 0 },
        { "init-lon",	1, NULL, 0 },
        { "init-alt",	1, NULL, 0 },
        { "init-heading",	1, NULL, 0 },
        { "init-dive",	1, NULL, 0 },
        { "init-pos-N",	0, NULL, 0 },
        { "init-pos-E",	0, NULL, 0 },
        { "init-pos-S",	0, NULL, 0 },
        { "init-pos-W",	0, NULL, 0 },
        { "init-pos-NE",	0, NULL, 0 },
        { "init-pos-SE",	0, NULL, 0 },
        { "init-pos-SW",	0, NULL, 0 },
        { "init-pos-NW",	0, NULL, 0 },
        { "init-pos-center",	0, NULL, 0 },
        { "init-ortho-lat",	1, NULL, 0 },
        { "init-ortho-lon",	1, NULL, 0 },
        { "init-ortho-width",	1, NULL, 0 },
        { "projection-cyl-platt",	0, NULL, 0 },
        { "projection-cyl-no1",	0, NULL, 0 },
        { "projection-pseudo-cyl-no1",	0, NULL, 0 },
        { "projection-cyl-mercator",	0, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      custom_optarg = optarg;
      custom_optind = optind;
      custom_opterr = opterr;
      custom_optopt = optopt;

      c = custom_getopt_long (argc, argv, "hVvqi:gbc:olfmaws:d:e:", long_options, &option_index);

      optarg = custom_optarg;
      optind = custom_optind;
      opterr = custom_opterr;
      optopt = custom_optopt;

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'v':	/* verbosity?.  */


          if (update_arg((void *)&(args_info->verbose_flag), 0, &(args_info->verbose_given),
              &(local_args_info.verbose_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "verbose", 'v',
              additional_error))
            goto failure;

          break;
        case 'q':	/* Querying openGL implementation.  */


          if (update_arg((void *)&(args_info->query_gl_flag), 0, &(args_info->query_gl_given),
              &(local_args_info.query_gl_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "query-gl", 'q',
              additional_error))
            goto failure;

          break;
        case 'i':	/* igc-file.  */


          if (update_arg( (void *)&(args_info->igc_file_arg),
               &(args_info->igc_file_orig), &(args_info->igc_file_given),
              &(local_args_info.igc_file_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "igc-file", 'i',
              additional_error))
            goto failure;

          break;
        case 'g':	/* use gps altitude.  */


          if (update_arg((void *)&(args_info->gpsalt_flag), 0, &(args_info->gpsalt_given),
              &(local_args_info.gpsalt_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "gpsalt", 'g',
              additional_error))
            goto failure;

          break;
        case 'b':	/* use barometric alt.  */


          if (update_arg((void *)&(args_info->baroalt_flag), 0, &(args_info->baroalt_given),
              &(local_args_info.baroalt_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "baroalt", 'b',
              additional_error))
            goto failure;

          break;
        case 'c':	/* config file.  */


          if (update_arg( (void *)&(args_info->config_file_arg),
               &(args_info->config_file_orig), &(args_info->config_file_given),
              &(local_args_info.config_file_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "config-file", 'c',
              additional_error))
            goto failure;

          break;
        case 'o':	/* 2D Orthographic View.  */


          if (update_arg((void *)&(args_info->ortho_flag), 0, &(args_info->ortho_given),
              &(local_args_info.ortho_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "ortho", 'o',
              additional_error))
            goto failure;

          break;
        case 'l':	/* landscape from dem.  */


          if (update_arg((void *)&(args_info->landscape_flag), 0, &(args_info->landscape_given),
              &(local_args_info.landscape_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "landscape", 'l',
              additional_error))
            goto failure;

          break;
        case 'f':	/* flat underground.  */


          if (update_arg((void *)&(args_info->flat_flag), 0, &(args_info->flat_given),
              &(local_args_info.flat_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "flat", 'f',
              additional_error))
            goto failure;

          break;
        case 'm':	/* display digitized maps.  */


          if (update_arg((void *)&(args_info->map_flag), 0, &(args_info->map_given),
              &(local_args_info.map_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "map", 'm',
              additional_error))
            goto failure;

          break;
        case 'a':	/* Airspace visualization.  */


          if (update_arg((void *)&(args_info->airspace_flag), 0, &(args_info->airspace_given),
              &(local_args_info.airspace_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "airspace", 'a',
              additional_error))
            goto failure;

          break;
        case 'w':	/* wireframe landscape.  */


          if (update_arg((void *)&(args_info->wire_flag), 0, &(args_info->wire_given),
              &(local_args_info.wire_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "wire", 'w',
              additional_error))
            goto failure;

          break;
        case 's':	/* z axis scaling.  */


          if (update_arg( (void *)&(args_info->scalez_arg),
               &(args_info->scalez_orig), &(args_info->scalez_given),
              &(local_args_info.scalez_given), optarg, 0, 0, ARG_FLOAT,
              check_ambiguity, override, 0, 0,
              "scalez", 's',
              additional_error))
            goto failure;

          break;
        case 'd':	/* dem raster downscaling.  */


          if (update_arg( (void *)&(args_info->downscaling_arg),
               &(args_info->downscaling_orig), &(args_info->downscaling_given),
              &(local_args_info.downscaling_given), optarg, 0, 0, ARG_INT,
              check_ambiguity, override, 0, 0,
              "downscaling", 'd',
              additional_error))
            goto failure;

          break;
        case 'e':	/* Elevation of airfield (take-off) in m.  */


          if (update_arg( (void *)&(args_info->airfield_elevation_arg),
               &(args_info->airfield_elevation_orig), &(args_info->airfield_elevation_given),
              &(local_args_info.airfield_elevation_given), optarg, 0, 0, ARG_INT,
              check_ambiguity, override, 0, 0,
              "airfield-elevation", 'e',
              additional_error))
            goto failure;

          break;

        case 0:	/* Long option with no short option */
          /* Quiet.  */
          if (strcmp (long_options[option_index].name, "quiet") == 0)
          {


            if (update_arg((void *)&(args_info->quiet_flag), 0, &(args_info->quiet_given),
                &(local_args_info.quiet_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "quiet", '-',
                additional_error))
              goto failure;

          }
          /* return exitcode 0.  */
          else if (strcmp (long_options[option_index].name, "check") == 0)
          {


            if (update_arg((void *)&(args_info->check_flag), 0, &(args_info->check_given),
                &(local_args_info.check_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "check", '-',
                additional_error))
              goto failure;

          }
          /* info about build.  */
          else if (strcmp (long_options[option_index].name, "compiler") == 0)
          {


            if (update_arg((void *)&(args_info->compiler_flag), 0, &(args_info->compiler_given),
                &(local_args_info.compiler_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "compiler", '-',
                additional_error))
              goto failure;

          }
          /* lots of output.  */
          else if (strcmp (long_options[option_index].name, "debug") == 0)
          {


            if (update_arg((void *)&(args_info->debug_flag), 0, &(args_info->debug_given),
                &(local_args_info.debug_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "debug", '-',
                additional_error))
              goto failure;

          }
          /* live gps via gpsd.  */
          else if (strcmp (long_options[option_index].name, "gpsd") == 0)
          {


            if (update_arg((void *)&(args_info->gpsd_flag), 0, &(args_info->gpsd_given),
                &(local_args_info.gpsd_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "gpsd", '-',
                additional_error))
              goto failure;

          }
          /* address of gpsd server.  */
          else if (strcmp (long_options[option_index].name, "gpsd-server") == 0)
          {


            if (update_arg( (void *)&(args_info->gpsd_server_arg),
                 &(args_info->gpsd_server_orig), &(args_info->gpsd_server_given),
                &(local_args_info.gpsd_server_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "gpsd-server", '-',
                additional_error))
              goto failure;

          }
          /* port of gpsd server.  */
          else if (strcmp (long_options[option_index].name, "gpsd-port") == 0)
          {


            if (update_arg( (void *)&(args_info->gpsd_port_arg),
                 &(args_info->gpsd_port_orig), &(args_info->gpsd_port_given),
                &(local_args_info.gpsd_port_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "gpsd-port", '-',
                additional_error))
              goto failure;

          }
          /* Use all position fixes.  */
          else if (strcmp (long_options[option_index].name, "use-all-fixes") == 0)
          {


            if (update_arg((void *)&(args_info->use_all_fixes_flag), 0, &(args_info->use_all_fixes_given),
                &(local_args_info.use_all_fixes_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "use-all-fixes", '-',
                additional_error))
              goto failure;

          }
          /* Latitude.  */
          else if (strcmp (long_options[option_index].name, "lat") == 0)
          {


            if (update_arg( (void *)&(args_info->lat_arg),
                 &(args_info->lat_orig), &(args_info->lat_given),
                &(local_args_info.lat_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "lat", '-',
                additional_error))
              goto failure;

          }
          /* Longitude.  */
          else if (strcmp (long_options[option_index].name, "lon") == 0)
          {


            if (update_arg( (void *)&(args_info->lon_arg),
                 &(args_info->lon_orig), &(args_info->lon_given),
                &(local_args_info.lon_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "lon", '-',
                additional_error))
              goto failure;

          }
          /* Return elevation of lat/lon.  */
          else if (strcmp (long_options[option_index].name, "get-elevation") == 0)
          {


            if (update_arg((void *)&(args_info->get_elevation_flag), 0, &(args_info->get_elevation_given),
                &(local_args_info.get_elevation_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-elevation", '-',
                additional_error))
              goto failure;

          }
          /* 3D View.  */
          else if (strcmp (long_options[option_index].name, "perspective") == 0)
          {


            if (update_arg((void *)&(args_info->perspective_flag), 0, &(args_info->perspective_given),
                &(local_args_info.perspective_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "perspective", '-',
                additional_error))
              goto failure;

          }
          /* angle of view.  */
          else if (strcmp (long_options[option_index].name, "aov") == 0)
          {


            if (update_arg( (void *)&(args_info->aov_arg),
                 &(args_info->aov_orig), &(args_info->aov_given),
                &(local_args_info.aov_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "aov", '-',
                additional_error))
              goto failure;

          }
          /* dont use maps.  */
          else if (strcmp (long_options[option_index].name, "no-map") == 0)
          {


            if (update_arg((void *)&(args_info->no_map_flag), 0, &(args_info->no_map_given),
                &(local_args_info.no_map_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-map", '-',
                additional_error))
              goto failure;

          }
          /* name of map set to use.  */
          else if (strcmp (long_options[option_index].name, "map-set-name") == 0)
          {


            if (update_arg( (void *)&(args_info->map_set_name_arg),
                 &(args_info->map_set_name_orig), &(args_info->map_set_name_given),
                &(local_args_info.map_set_name_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "map-set-name", '-',
                additional_error))
              goto failure;

          }
          /* dem color and maps.  */
          else if (strcmp (long_options[option_index].name, "modulate") == 0)
          {


            if (update_arg((void *)&(args_info->modulate_flag), 0, &(args_info->modulate_given),
                &(local_args_info.modulate_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "modulate", '-',
                additional_error))
              goto failure;

          }
          /* no color modulation.  */
          else if (strcmp (long_options[option_index].name, "no-modulate") == 0)
          {


            if (update_arg((void *)&(args_info->no_modulate_flag), 0, &(args_info->no_modulate_given),
                &(local_args_info.no_modulate_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-modulate", '-',
                additional_error))
              goto failure;

          }
          /* dont use lighting for unmodulated maps.  */
          else if (strcmp (long_options[option_index].name, "maps-unlighted") == 0)
          {


            if (update_arg((void *)&(args_info->maps_unlighted_flag), 0, &(args_info->maps_unlighted_given),
                &(local_args_info.maps_unlighted_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "maps-unlighted", '-',
                additional_error))
              goto failure;

          }
          /* use lighting for unmodulated maps.  */
          else if (strcmp (long_options[option_index].name, "maps-lighted") == 0)
          {


            if (update_arg((void *)&(args_info->maps_lighted_flag), 0, &(args_info->maps_lighted_given),
                &(local_args_info.maps_lighted_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "maps-lighted", '-',
                additional_error))
              goto failure;

          }
          /* Dont use lighting for terrain.  */
          else if (strcmp (long_options[option_index].name, "no-lighting") == 0)
          {


            if (update_arg((void *)&(args_info->no_lighting_flag), 0, &(args_info->no_lighting_given),
                &(local_args_info.no_lighting_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-lighting", '-',
                additional_error))
              goto failure;

          }
          /* Use terrain shading (implies no-lighting).  */
          else if (strcmp (long_options[option_index].name, "terrain-shading") == 0)
          {


            if (update_arg((void *)&(args_info->terrain_shading_flag), 0, &(args_info->terrain_shading_given),
                &(local_args_info.terrain_shading_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "terrain-shading", '-',
                additional_error))
              goto failure;

          }
          /* shading-scale (1-10000).  */
          else if (strcmp (long_options[option_index].name, "shading-scale") == 0)
          {


            if (update_arg( (void *)&(args_info->shading_scale_arg),
                 &(args_info->shading_scale_orig), &(args_info->shading_scale_given),
                &(local_args_info.shading_scale_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "shading-scale", '-',
                additional_error))
              goto failure;

          }
          /* direction for light (1-8).  */
          else if (strcmp (long_options[option_index].name, "light-direction") == 0)
          {


            if (update_arg( (void *)&(args_info->light_direction_arg),
                 &(args_info->light_direction_orig), &(args_info->light_direction_given),
                &(local_args_info.light_direction_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "light-direction", '-',
                additional_error))
              goto failure;

          }
          /* Airspace as wireframe.  */
          else if (strcmp (long_options[option_index].name, "airspace-wire") == 0)
          {


            if (update_arg((void *)&(args_info->airspace_wire_flag), 0, &(args_info->airspace_wire_given),
                &(local_args_info.airspace_wire_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "airspace-wire", '-',
                additional_error))
              goto failure;

          }
          /* wire color red.  */
          else if (strcmp (long_options[option_index].name, "airspace-wire-col-r") == 0)
          {


            if (update_arg( (void *)&(args_info->airspace_wire_col_r_arg),
                 &(args_info->airspace_wire_col_r_orig), &(args_info->airspace_wire_col_r_given),
                &(local_args_info.airspace_wire_col_r_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "airspace-wire-col-r", '-',
                additional_error))
              goto failure;

          }
          /* wire color green.  */
          else if (strcmp (long_options[option_index].name, "airspace-wire-col-g") == 0)
          {


            if (update_arg( (void *)&(args_info->airspace_wire_col_g_arg),
                 &(args_info->airspace_wire_col_g_orig), &(args_info->airspace_wire_col_g_given),
                &(local_args_info.airspace_wire_col_g_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "airspace-wire-col-g", '-',
                additional_error))
              goto failure;

          }
          /* wire color blue.  */
          else if (strcmp (long_options[option_index].name, "airspace-wire-col-b") == 0)
          {


            if (update_arg( (void *)&(args_info->airspace_wire_col_b_arg),
                 &(args_info->airspace_wire_col_b_orig), &(args_info->airspace_wire_col_b_given),
                &(local_args_info.airspace_wire_col_b_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "airspace-wire-col-b", '-',
                additional_error))
              goto failure;

          }
          /* linewidth wires.  */
          else if (strcmp (long_options[option_index].name, "airspace-wire-width") == 0)
          {


            if (update_arg( (void *)&(args_info->airspace_wire_width_arg),
                 &(args_info->airspace_wire_width_orig), &(args_info->airspace_wire_width_given),
                &(local_args_info.airspace_wire_width_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "airspace-wire-width", '-',
                additional_error))
              goto failure;

          }
          /* Airspace transparent.  */
          else if (strcmp (long_options[option_index].name, "airspace-transparent") == 0)
          {


            if (update_arg((void *)&(args_info->airspace_transparent_flag), 0, &(args_info->airspace_transparent_given),
                &(local_args_info.airspace_transparent_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "airspace-transparent", '-',
                additional_error))
              goto failure;

          }
          /* no Airspaces.  */
          else if (strcmp (long_options[option_index].name, "no-airspace") == 0)
          {


            if (update_arg((void *)&(args_info->no_airspace_flag), 0, &(args_info->no_airspace_given),
                &(local_args_info.no_airspace_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-airspace", '-',
                additional_error))
              goto failure;

          }
          /* use airspaces from file.  */
          else if (strcmp (long_options[option_index].name, "airspace-file") == 0)
          {


            if (update_arg( (void *)&(args_info->airspace_file_arg),
                 &(args_info->airspace_file_orig), &(args_info->airspace_file_given),
                &(local_args_info.airspace_file_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "airspace-file", '-',
                additional_error))
              goto failure;

          }
          /* limit (FL) for airspaces.  */
          else if (strcmp (long_options[option_index].name, "airspace-limit") == 0)
          {


            if (update_arg( (void *)&(args_info->airspace_limit_arg),
                 &(args_info->airspace_limit_orig), &(args_info->airspace_limit_given),
                &(local_args_info.airspace_limit_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "airspace-limit", '-',
                additional_error))
              goto failure;

          }
          /* filled polygons.  */
          else if (strcmp (long_options[option_index].name, "filled") == 0)
          {


            if (update_arg((void *)&(args_info->filled_flag), 0, &(args_info->filled_given),
                &(local_args_info.filled_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "filled", '-',
                additional_error))
              goto failure;

          }
          /* grayscaled image.  */
          else if (strcmp (long_options[option_index].name, "grayscale") == 0)
          {


            if (update_arg((void *)&(args_info->grayscale_flag), 0, &(args_info->grayscale_given),
                &(local_args_info.grayscale_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "grayscale", '-',
                additional_error))
              goto failure;

          }
          /* color image.  */
          else if (strcmp (long_options[option_index].name, "color") == 0)
          {


            if (update_arg((void *)&(args_info->color_flag), 0, &(args_info->color_given),
                &(local_args_info.color_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "color", '-',
                additional_error))
              goto failure;

          }
          /* stereoscopic.  */
          else if (strcmp (long_options[option_index].name, "stereo") == 0)
          {


            if (update_arg((void *)&(args_info->stereo_flag), 0, &(args_info->stereo_given),
                &(local_args_info.stereo_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "stereo", '-',
                additional_error))
              goto failure;

          }
          /* no stereoscopic view.  */
          else if (strcmp (long_options[option_index].name, "no-stereo") == 0)
          {


            if (update_arg((void *)&(args_info->no_stereo_flag), 0, &(args_info->no_stereo_given),
                &(local_args_info.no_stereo_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-stereo", '-',
                additional_error))
              goto failure;

          }
          /* stereoscopic red/green.  */
          else if (strcmp (long_options[option_index].name, "stereo-rg") == 0)
          {


            if (update_arg((void *)&(args_info->stereo_rg_flag), 0, &(args_info->stereo_rg_given),
                &(local_args_info.stereo_rg_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "stereo-rg", '-',
                additional_error))
              goto failure;

          }
          /* no stereoscopic red/green.  */
          else if (strcmp (long_options[option_index].name, "no-stereo-rg") == 0)
          {


            if (update_arg((void *)&(args_info->no_stereo_rg_flag), 0, &(args_info->no_stereo_rg_given),
                &(local_args_info.no_stereo_rg_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-stereo-rg", '-',
                additional_error))
              goto failure;

          }
          /* stereoscopic red/blue.  */
          else if (strcmp (long_options[option_index].name, "stereo-rb") == 0)
          {


            if (update_arg((void *)&(args_info->stereo_rb_flag), 0, &(args_info->stereo_rb_given),
                &(local_args_info.stereo_rb_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "stereo-rb", '-',
                additional_error))
              goto failure;

          }
          /* no stereoscopic red/blue.  */
          else if (strcmp (long_options[option_index].name, "no-stereo-rb") == 0)
          {


            if (update_arg((void *)&(args_info->no_stereo_rb_flag), 0, &(args_info->no_stereo_rb_given),
                &(local_args_info.no_stereo_rb_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-stereo-rb", '-',
                additional_error))
              goto failure;

          }
          /* stereoscopic hardware.  */
          else if (strcmp (long_options[option_index].name, "stereo-hw") == 0)
          {


            if (update_arg((void *)&(args_info->stereo_hw_flag), 0, &(args_info->stereo_hw_given),
                &(local_args_info.stereo_hw_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "stereo-hw", '-',
                additional_error))
              goto failure;

          }
          /* no stereoscopic hardware.  */
          else if (strcmp (long_options[option_index].name, "no-stereo-hw") == 0)
          {


            if (update_arg((void *)&(args_info->no_stereo_hw_flag), 0, &(args_info->no_stereo_hw_given),
                &(local_args_info.no_stereo_hw_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-stereo-hw", '-',
                additional_error))
              goto failure;

          }
          /* invert right/left image.  */
          else if (strcmp (long_options[option_index].name, "inverse-stereo") == 0)
          {


            if (update_arg((void *)&(args_info->inverse_stereo_flag), 0, &(args_info->inverse_stereo_given),
                &(local_args_info.inverse_stereo_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "inverse-stereo", '-',
                additional_error))
              goto failure;

          }
          /* dont invert right/left.  */
          else if (strcmp (long_options[option_index].name, "no-inverse-stereo") == 0)
          {


            if (update_arg((void *)&(args_info->no_inverse_stereo_flag), 0, &(args_info->no_inverse_stereo_given),
                &(local_args_info.no_inverse_stereo_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-inverse-stereo", '-',
                additional_error))
              goto failure;

          }
          /* eye distance for stereoscopic view (km).  */
          else if (strcmp (long_options[option_index].name, "eye-dist") == 0)
          {


            if (update_arg( (void *)&(args_info->eye_dist_arg),
                 &(args_info->eye_dist_orig), &(args_info->eye_dist_given),
                &(local_args_info.eye_dist_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "eye-dist", '-',
                additional_error))
              goto failure;

          }
          /* no gouraud.  */
          else if (strcmp (long_options[option_index].name, "flat-shading") == 0)
          {


            if (update_arg((void *)&(args_info->flat_shading_flag), 0, &(args_info->flat_shading_given),
                &(local_args_info.flat_shading_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "flat-shading", '-',
                additional_error))
              goto failure;

          }
          /* use gouraud-shading.  */
          else if (strcmp (long_options[option_index].name, "gouraud-shading") == 0)
          {


            if (update_arg((void *)&(args_info->gouraud_shading_flag), 0, &(args_info->gouraud_shading_given),
                &(local_args_info.gouraud_shading_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "gouraud-shading", '-',
                additional_error))
              goto failure;

          }
          /* use quadrilaterals.  */
          else if (strcmp (long_options[option_index].name, "quads") == 0)
          {


            if (update_arg((void *)&(args_info->quads_flag), 0, &(args_info->quads_given),
                &(local_args_info.quads_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "quads", '-',
                additional_error))
              goto failure;

          }
          /* draw curtain.  */
          else if (strcmp (long_options[option_index].name, "curtain") == 0)
          {


            if (update_arg((void *)&(args_info->curtain_flag), 0, &(args_info->curtain_given),
                &(local_args_info.curtain_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "curtain", '-',
                additional_error))
              goto failure;

          }
          /* draw no curtain.  */
          else if (strcmp (long_options[option_index].name, "no-curtain") == 0)
          {


            if (update_arg((void *)&(args_info->no_curtain_flag), 0, &(args_info->no_curtain_given),
                &(local_args_info.no_curtain_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-curtain", '-',
                additional_error))
              goto failure;

          }
          /* draw haze.  */
          else if (strcmp (long_options[option_index].name, "haze") == 0)
          {


            if (update_arg((void *)&(args_info->haze_flag), 0, &(args_info->haze_given),
                &(local_args_info.haze_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "haze", '-',
                additional_error))
              goto failure;

          }
          /* draw no haze.  */
          else if (strcmp (long_options[option_index].name, "no-haze") == 0)
          {


            if (update_arg((void *)&(args_info->no_haze_flag), 0, &(args_info->no_haze_given),
                &(local_args_info.no_haze_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-haze", '-',
                additional_error))
              goto failure;

          }
          /* haze density (0-0.5).  */
          else if (strcmp (long_options[option_index].name, "haze-density") == 0)
          {


            if (update_arg( (void *)&(args_info->haze_density_arg),
                 &(args_info->haze_density_orig), &(args_info->haze_density_given),
                &(local_args_info.haze_density_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "haze-density", '-',
                additional_error))
              goto failure;

          }
          /* no. of colormap to use.  */
          else if (strcmp (long_options[option_index].name, "colormap") == 0)
          {


            if (update_arg( (void *)&(args_info->colormap_arg),
                 &(args_info->colormap_orig), &(args_info->colormap_given),
                &(local_args_info.colormap_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "colormap", '-',
                additional_error))
              goto failure;

          }
          /* colormap 2 (sea).  */
          else if (strcmp (long_options[option_index].name, "colormap-sea") == 0)
          {


            if (update_arg( (void *)&(args_info->colormap_sea_arg),
                 &(args_info->colormap_sea_orig), &(args_info->colormap_sea_given),
                &(local_args_info.colormap_sea_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "colormap-sea", '-',
                additional_error))
              goto failure;

          }
          /* mininum height.  */
          else if (strcmp (long_options[option_index].name, "colormap-min") == 0)
          {


            if (update_arg( (void *)&(args_info->colormap_min_arg),
                 &(args_info->colormap_min_orig), &(args_info->colormap_min_given),
                &(local_args_info.colormap_min_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "colormap-min", '-',
                additional_error))
              goto failure;

          }
          /* maximum height.  */
          else if (strcmp (long_options[option_index].name, "colormap-max") == 0)
          {


            if (update_arg( (void *)&(args_info->colormap_max_arg),
                 &(args_info->colormap_max_orig), &(args_info->colormap_max_given),
                &(local_args_info.colormap_max_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "colormap-max", '-',
                additional_error))
              goto failure;

          }
          /* set sealevel.  */
          else if (strcmp (long_options[option_index].name, "sealevel") == 0)
          {


            if (update_arg( (void *)&(args_info->sealevel_arg),
                 &(args_info->sealevel_orig), &(args_info->sealevel_given),
                &(local_args_info.sealevel_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "sealevel", '-',
                additional_error))
              goto failure;

          }
          /* set sealevel2.  */
          else if (strcmp (long_options[option_index].name, "sealevel2") == 0)
          {


            if (update_arg( (void *)&(args_info->sealevel2_arg),
                 &(args_info->sealevel2_orig), &(args_info->sealevel2_given),
                &(local_args_info.sealevel2_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "sealevel2", '-',
                additional_error))
              goto failure;

          }
          /* set sealevel3.  */
          else if (strcmp (long_options[option_index].name, "sealevel3") == 0)
          {


            if (update_arg( (void *)&(args_info->sealevel3_arg),
                 &(args_info->sealevel3_orig), &(args_info->sealevel3_given),
                &(local_args_info.sealevel3_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "sealevel3", '-',
                additional_error))
              goto failure;

          }
          /* ignore range min.  */
          else if (strcmp (long_options[option_index].name, "ignore-elev-min") == 0)
          {


            if (update_arg( (void *)&(args_info->ignore_elev_min_arg),
                 &(args_info->ignore_elev_min_orig), &(args_info->ignore_elev_min_given),
                &(local_args_info.ignore_elev_min_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ignore-elev-min", '-',
                additional_error))
              goto failure;

          }
          /* ignore range max.  */
          else if (strcmp (long_options[option_index].name, "ignore-elev-max") == 0)
          {


            if (update_arg( (void *)&(args_info->ignore_elev_max_arg),
                 &(args_info->ignore_elev_max_orig), &(args_info->ignore_elev_max_given),
                &(local_args_info.ignore_elev_max_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ignore-elev-max", '-',
                additional_error))
              goto failure;

          }
          /* dem raster interpolation factor.  */
          else if (strcmp (long_options[option_index].name, "upscaling") == 0)
          {


            if (update_arg( (void *)&(args_info->upscaling_arg),
                 &(args_info->upscaling_orig), &(args_info->upscaling_given),
                &(local_args_info.upscaling_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "upscaling", '-',
                additional_error))
              goto failure;

          }
          /* Fullscreen.  */
          else if (strcmp (long_options[option_index].name, "fullscreen") == 0)
          {


            if (update_arg((void *)&(args_info->fullscreen_flag), 0, &(args_info->fullscreen_given),
                &(local_args_info.fullscreen_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "fullscreen", '-',
                additional_error))
              goto failure;

          }
          /* start windowed.  */
          else if (strcmp (long_options[option_index].name, "window") == 0)
          {


            if (update_arg((void *)&(args_info->window_flag), 0, &(args_info->window_given),
                &(local_args_info.window_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "window", '-',
                additional_error))
              goto failure;

          }
          /* Window width.  */
          else if (strcmp (long_options[option_index].name, "width") == 0)
          {


            if (update_arg( (void *)&(args_info->width_arg),
                 &(args_info->width_orig), &(args_info->width_given),
                &(local_args_info.width_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "width", '-',
                additional_error))
              goto failure;

          }
          /* Window height.  */
          else if (strcmp (long_options[option_index].name, "height") == 0)
          {


            if (update_arg( (void *)&(args_info->height_arg),
                 &(args_info->height_orig), &(args_info->height_given),
                &(local_args_info.height_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "height", '-',
                additional_error))
              goto failure;

          }
          /* Border Lat and Lon.  */
          else if (strcmp (long_options[option_index].name, "border") == 0)
          {


            if (update_arg( (void *)&(args_info->border_arg),
                 &(args_info->border_orig), &(args_info->border_given),
                &(local_args_info.border_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "border", '-',
                additional_error))
              goto failure;

          }
          /* Border Lat.  */
          else if (strcmp (long_options[option_index].name, "border-lat") == 0)
          {


            if (update_arg( (void *)&(args_info->border_lat_arg),
                 &(args_info->border_lat_orig), &(args_info->border_lat_given),
                &(local_args_info.border_lat_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "border-lat", '-',
                additional_error))
              goto failure;

          }
          /* Border Lon.  */
          else if (strcmp (long_options[option_index].name, "border-lon") == 0)
          {


            if (update_arg( (void *)&(args_info->border_lon_arg),
                 &(args_info->border_lon_orig), &(args_info->border_lon_given),
                &(local_args_info.border_lon_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "border-lon", '-',
                additional_error))
              goto failure;

          }
          /* height offset in m.  */
          else if (strcmp (long_options[option_index].name, "offset") == 0)
          {


            if (update_arg( (void *)&(args_info->offset_arg),
                 &(args_info->offset_orig), &(args_info->offset_given),
                &(local_args_info.offset_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "offset", '-',
                additional_error))
              goto failure;

          }
          /* Position of marker.  */
          else if (strcmp (long_options[option_index].name, "marker-pos") == 0)
          {


            if (update_arg( (void *)&(args_info->marker_pos_arg),
                 &(args_info->marker_pos_orig), &(args_info->marker_pos_given),
                &(local_args_info.marker_pos_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "marker-pos", '-',
                additional_error))
              goto failure;

          }
          /* Time of markerposition.  */
          else if (strcmp (long_options[option_index].name, "marker-time") == 0)
          {


            if (update_arg( (void *)&(args_info->marker_time_arg),
                 &(args_info->marker_time_orig), &(args_info->marker_time_given),
                &(local_args_info.marker_time_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "marker-time", '-',
                additional_error))
              goto failure;

          }
          /* Marker.  */
          else if (strcmp (long_options[option_index].name, "marker") == 0)
          {


            if (update_arg((void *)&(args_info->marker_flag), 0, &(args_info->marker_given),
                &(local_args_info.marker_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "marker", '-',
                additional_error))
              goto failure;

          }
          /* Size of the Marker.  */
          else if (strcmp (long_options[option_index].name, "marker-size") == 0)
          {


            if (update_arg( (void *)&(args_info->marker_size_arg),
                 &(args_info->marker_size_orig), &(args_info->marker_size_given),
                &(local_args_info.marker_size_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "marker-size", '-',
                additional_error))
              goto failure;

          }
          /* no Marker.  */
          else if (strcmp (long_options[option_index].name, "no-marker") == 0)
          {


            if (update_arg((void *)&(args_info->no_marker_flag), 0, &(args_info->no_marker_given),
                &(local_args_info.no_marker_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-marker", '-',
                additional_error))
              goto failure;

          }
          /* Info text display.  */
          else if (strcmp (long_options[option_index].name, "info") == 0)
          {


            if (update_arg((void *)&(args_info->info_flag), 0, &(args_info->info_given),
                &(local_args_info.info_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "info", '-',
                additional_error))
              goto failure;

          }
          /* no info text display.  */
          else if (strcmp (long_options[option_index].name, "no-info") == 0)
          {


            if (update_arg((void *)&(args_info->no_info_flag), 0, &(args_info->no_info_given),
                &(local_args_info.no_info_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-info", '-',
                additional_error))
              goto failure;

          }
          /* Text string to display.  */
          else if (strcmp (long_options[option_index].name, "text") == 0)
          {


            if (update_arg( (void *)&(args_info->text_arg),
                 &(args_info->text_orig), &(args_info->text_given),
                &(local_args_info.text_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "text", '-',
                additional_error))
              goto failure;

          }
          /* Turn off viewpoint position info.  */
          else if (strcmp (long_options[option_index].name, "no-position-info") == 0)
          {


            if (update_arg((void *)&(args_info->no_position_info_flag), 0, &(args_info->no_position_info_given),
                &(local_args_info.no_position_info_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-position-info", '-',
                additional_error))
              goto failure;

          }
          /* Turn off marker position info.  */
          else if (strcmp (long_options[option_index].name, "no-marker-pos-info") == 0)
          {


            if (update_arg((void *)&(args_info->no_marker_pos_info_flag), 0, &(args_info->no_marker_pos_info_given),
                &(local_args_info.no_marker_pos_info_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-marker-pos-info", '-',
                additional_error))
              goto failure;

          }
          /* Size of text for points/lifts (0.001-1.0).  */
          else if (strcmp (long_options[option_index].name, "text-size") == 0)
          {


            if (update_arg( (void *)&(args_info->text_size_arg),
                 &(args_info->text_size_orig), &(args_info->text_size_given),
                &(local_args_info.text_size_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "text-size", '-',
                additional_error))
              goto failure;

          }
          /* Width of text (1-20).  */
          else if (strcmp (long_options[option_index].name, "text-width") == 0)
          {


            if (update_arg( (void *)&(args_info->text_width_arg),
                 &(args_info->text_width_orig), &(args_info->text_width_given),
                &(local_args_info.text_width_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "text-width", '-',
                additional_error))
              goto failure;

          }
          /* GPLIGC liftsfile.  */
          else if (strcmp (long_options[option_index].name, "lifts") == 0)
          {


            if (update_arg( (void *)&(args_info->lifts_arg),
                 &(args_info->lifts_orig), &(args_info->lifts_given),
                &(local_args_info.lifts_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "lifts", '-',
                additional_error))
              goto failure;

          }
          /* which info to display (1-7).  */
          else if (strcmp (long_options[option_index].name, "lifts-info-mode") == 0)
          {


            if (update_arg( (void *)&(args_info->lifts_info_mode_arg),
                 &(args_info->lifts_info_mode_orig), &(args_info->lifts_info_mode_given),
                &(local_args_info.lifts_info_mode_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "lifts-info-mode", '-',
                additional_error))
              goto failure;

          }
          /* waypointsfile.  */
          else if (strcmp (long_options[option_index].name, "waypoints-file") == 0)
          {


            if (update_arg( (void *)&(args_info->waypoints_file_arg),
                 &(args_info->waypoints_file_orig), &(args_info->waypoints_file_given),
                &(local_args_info.waypoints_file_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "waypoints-file", '-',
                additional_error))
              goto failure;

          }
          /* show waypoints.  */
          else if (strcmp (long_options[option_index].name, "waypoints") == 0)
          {


            if (update_arg((void *)&(args_info->waypoints_flag), 0, &(args_info->waypoints_given),
                &(local_args_info.waypoints_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "waypoints", '-',
                additional_error))
              goto failure;

          }
          /* dont show waypoints.  */
          else if (strcmp (long_options[option_index].name, "no-waypoints") == 0)
          {


            if (update_arg((void *)&(args_info->no_waypoints_flag), 0, &(args_info->no_waypoints_given),
                &(local_args_info.no_waypoints_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-waypoints", '-',
                additional_error))
              goto failure;

          }
          /* which info to display (1-4).  */
          else if (strcmp (long_options[option_index].name, "waypoints-info-mode") == 0)
          {


            if (update_arg( (void *)&(args_info->waypoints_info_mode_arg),
                 &(args_info->waypoints_info_mode_orig), &(args_info->waypoints_info_mode_given),
                &(local_args_info.waypoints_info_mode_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "waypoints-info-mode", '-',
                additional_error))
              goto failure;

          }
          /* offset for displaying waypoint text in 3D.  */
          else if (strcmp (long_options[option_index].name, "waypoints-offset") == 0)
          {


            if (update_arg( (void *)&(args_info->waypoints_offset_arg),
                 &(args_info->waypoints_offset_orig), &(args_info->waypoints_offset_given),
                &(local_args_info.waypoints_offset_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "waypoints-offset", '-',
                additional_error))
              goto failure;

          }
          /* offset for displaying waypoint spheres and text in 3D.  */
          else if (strcmp (long_options[option_index].name, "waypoints-offset-spheres") == 0)
          {


            if (update_arg( (void *)&(args_info->waypoints_offset_spheres_arg),
                 &(args_info->waypoints_offset_spheres_orig), &(args_info->waypoints_offset_spheres_given),
                &(local_args_info.waypoints_offset_spheres_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "waypoints-offset-spheres", '-',
                additional_error))
              goto failure;

          }
          /* sets the mode of track display.  */
          else if (strcmp (long_options[option_index].name, "flighttrack-mode") == 0)
          {


            if (update_arg( (void *)&(args_info->flighttrack_mode_arg),
                 &(args_info->flighttrack_mode_orig), &(args_info->flighttrack_mode_given),
                &(local_args_info.flighttrack_mode_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "flighttrack-mode", '-',
                additional_error))
              goto failure;

          }
          /* sets the colourmap for flighttrack.  */
          else if (strcmp (long_options[option_index].name, "flighttrack-colormap") == 0)
          {


            if (update_arg( (void *)&(args_info->flighttrack_colormap_arg),
                 &(args_info->flighttrack_colormap_orig), &(args_info->flighttrack_colormap_given),
                &(local_args_info.flighttrack_colormap_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "flighttrack-colormap", '-',
                additional_error))
              goto failure;

          }
          /* sets the linewidth of the flighttrack.  */
          else if (strcmp (long_options[option_index].name, "flighttrack-linewidth") == 0)
          {


            if (update_arg( (void *)&(args_info->flighttrack_linewidth_arg),
                 &(args_info->flighttrack_linewidth_orig), &(args_info->flighttrack_linewidth_given),
                &(local_args_info.flighttrack_linewidth_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "flighttrack-linewidth", '-',
                additional_error))
              goto failure;

          }
          /* viewpoint follows marker.  */
          else if (strcmp (long_options[option_index].name, "follow") == 0)
          {


            if (update_arg((void *)&(args_info->follow_flag), 0, &(args_info->follow_given),
                &(local_args_info.follow_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "follow", '-',
                additional_error))
              goto failure;

          }
          /* viewpoint doesnt follow marker.  */
          else if (strcmp (long_options[option_index].name, "no-follow") == 0)
          {


            if (update_arg((void *)&(args_info->no_follow_flag), 0, &(args_info->no_follow_given),
                &(local_args_info.no_follow_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-follow", '-',
                additional_error))
              goto failure;

          }
          /* range around marker is plottet.  */
          else if (strcmp (long_options[option_index].name, "marker-range") == 0)
          {


            if (update_arg((void *)&(args_info->marker_range_flag), 0, &(args_info->marker_range_given),
                &(local_args_info.marker_range_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "marker-range", '-',
                additional_error))
              goto failure;

          }
          /* full flight is displayed.  */
          else if (strcmp (long_options[option_index].name, "no-marker-range") == 0)
          {


            if (update_arg((void *)&(args_info->no_marker_range_flag), 0, &(args_info->no_marker_range_given),
                &(local_args_info.no_marker_range_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-marker-range", '-',
                additional_error))
              goto failure;

          }
          /* define marker range.  */
          else if (strcmp (long_options[option_index].name, "marker-ahead") == 0)
          {


            if (update_arg( (void *)&(args_info->marker_ahead_arg),
                 &(args_info->marker_ahead_orig), &(args_info->marker_ahead_given),
                &(local_args_info.marker_ahead_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "marker-ahead", '-',
                additional_error))
              goto failure;

          }
          /* define marker range.  */
          else if (strcmp (long_options[option_index].name, "marker-back") == 0)
          {


            if (update_arg( (void *)&(args_info->marker_back_arg),
                 &(args_info->marker_back_orig), &(args_info->marker_back_given),
                &(local_args_info.marker_back_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "marker-back", '-',
                additional_error))
              goto failure;

          }
          /* start up in movie mode.  */
          else if (strcmp (long_options[option_index].name, "movie") == 0)
          {


            if (update_arg((void *)&(args_info->movie_flag), 0, &(args_info->movie_given),
                &(local_args_info.movie_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "movie", '-',
                additional_error))
              goto failure;

          }
          /* cycles for movie mode.  */
          else if (strcmp (long_options[option_index].name, "cycles") == 0)
          {


            if (update_arg( (void *)&(args_info->cycles_arg),
                 &(args_info->cycles_orig), &(args_info->cycles_given),
                &(local_args_info.cycles_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "cycles", '-',
                additional_error))
              goto failure;

          }
          /* spinning for movie mode.  */
          else if (strcmp (long_options[option_index].name, "spinning") == 0)
          {


            if (update_arg( (void *)&(args_info->spinning_arg),
                 &(args_info->spinning_orig), &(args_info->spinning_given),
                &(local_args_info.spinning_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "spinning", '-',
                additional_error))
              goto failure;

          }
          /* smooth movement.  */
          else if (strcmp (long_options[option_index].name, "smooth-mouse") == 0)
          {


            if (update_arg((void *)&(args_info->smooth_mouse_flag), 0, &(args_info->smooth_mouse_given),
                &(local_args_info.smooth_mouse_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "smooth-mouse", '-',
                additional_error))
              goto failure;

          }
          /* PID of parent.  */
          else if (strcmp (long_options[option_index].name, "parent-pid") == 0)
          {


            if (update_arg( (void *)&(args_info->parent_pid_arg),
                 &(args_info->parent_pid_orig), &(args_info->parent_pid_given),
                &(local_args_info.parent_pid_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "parent-pid", '-',
                additional_error))
              goto failure;

          }
          /* Use texture map compression.  */
          else if (strcmp (long_options[option_index].name, "compression") == 0)
          {


            if (update_arg((void *)&(args_info->compression_flag), 0, &(args_info->compression_given),
                &(local_args_info.compression_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "compression", '-',
                additional_error))
              goto failure;

          }
          /* Dont use texture map compression.  */
          else if (strcmp (long_options[option_index].name, "no-compression") == 0)
          {


            if (update_arg((void *)&(args_info->no_compression_flag), 0, &(args_info->no_compression_given),
                &(local_args_info.no_compression_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-compression", '-',
                additional_error))
              goto failure;

          }
          /* Offscreen with GLX.  */
          else if (strcmp (long_options[option_index].name, "offscreen") == 0)
          {


            if (update_arg((void *)&(args_info->offscreen_flag), 0, &(args_info->offscreen_given),
                &(local_args_info.offscreen_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "offscreen", '-',
                additional_error))
              goto failure;

          }
          /* Offscreen with Mesa.  */
          else if (strcmp (long_options[option_index].name, "osmesa") == 0)
          {


            if (update_arg((void *)&(args_info->osmesa_flag), 0, &(args_info->osmesa_given),
                &(local_args_info.osmesa_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "osmesa", '-',
                additional_error))
              goto failure;

          }
          /* outfile for offscreen rendering.  */
          else if (strcmp (long_options[option_index].name, "os-outfile") == 0)
          {


            if (update_arg( (void *)&(args_info->os_outfile_arg),
                 &(args_info->os_outfile_orig), &(args_info->os_outfile_given),
                &(local_args_info.os_outfile_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "os-outfile", '-',
                additional_error))
              goto failure;

          }
          /* Quality (0-100) of jpeg output.  */
          else if (strcmp (long_options[option_index].name, "jpeg-quality") == 0)
          {


            if (update_arg( (void *)&(args_info->jpeg_quality_arg),
                 &(args_info->jpeg_quality_orig), &(args_info->jpeg_quality_given),
                &(local_args_info.jpeg_quality_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "jpeg-quality", '-',
                additional_error))
              goto failure;

          }
          /* Image format for screenshots.  */
          else if (strcmp (long_options[option_index].name, "image-format") == 0)
          {


            if (update_arg( (void *)&(args_info->image_format_arg),
                 &(args_info->image_format_orig), &(args_info->image_format_given),
                &(local_args_info.image_format_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "image-format", '-',
                additional_error))
              goto failure;

          }
          /* Path to save screenshots.  */
          else if (strcmp (long_options[option_index].name, "save-path") == 0)
          {


            if (update_arg( (void *)&(args_info->save_path_arg),
                 &(args_info->save_path_orig), &(args_info->save_path_given),
                &(local_args_info.save_path_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "save-path", '-',
                additional_error))
              goto failure;

          }
          /* Basename of screenshots.  */
          else if (strcmp (long_options[option_index].name, "basename") == 0)
          {


            if (update_arg( (void *)&(args_info->basename_arg),
                 &(args_info->basename_orig), &(args_info->basename_given),
                &(local_args_info.basename_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "basename", '-',
                additional_error))
              goto failure;

          }
          /* clipping far.  */
          else if (strcmp (long_options[option_index].name, "clipping-far") == 0)
          {


            if (update_arg( (void *)&(args_info->clipping_far_arg),
                 &(args_info->clipping_far_orig), &(args_info->clipping_far_given),
                &(local_args_info.clipping_far_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "clipping-far", '-',
                additional_error))
              goto failure;

          }
          /* clipping near.  */
          else if (strcmp (long_options[option_index].name, "clipping-near") == 0)
          {


            if (update_arg( (void *)&(args_info->clipping_near_arg),
                 &(args_info->clipping_near_orig), &(args_info->clipping_near_given),
                &(local_args_info.clipping_near_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "clipping-near", '-',
                additional_error))
              goto failure;

          }
          /* set initial latitude.  */
          else if (strcmp (long_options[option_index].name, "init-lat") == 0)
          {


            if (update_arg( (void *)&(args_info->init_lat_arg),
                 &(args_info->init_lat_orig), &(args_info->init_lat_given),
                &(local_args_info.init_lat_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "init-lat", '-',
                additional_error))
              goto failure;

          }
          /* set initial longitude.  */
          else if (strcmp (long_options[option_index].name, "init-lon") == 0)
          {


            if (update_arg( (void *)&(args_info->init_lon_arg),
                 &(args_info->init_lon_orig), &(args_info->init_lon_given),
                &(local_args_info.init_lon_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "init-lon", '-',
                additional_error))
              goto failure;

          }
          /* set initial altitude.  */
          else if (strcmp (long_options[option_index].name, "init-alt") == 0)
          {


            if (update_arg( (void *)&(args_info->init_alt_arg),
                 &(args_info->init_alt_orig), &(args_info->init_alt_given),
                &(local_args_info.init_alt_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "init-alt", '-',
                additional_error))
              goto failure;

          }
          /* set initial heading.  */
          else if (strcmp (long_options[option_index].name, "init-heading") == 0)
          {


            if (update_arg( (void *)&(args_info->init_heading_arg),
                 &(args_info->init_heading_orig), &(args_info->init_heading_given),
                &(local_args_info.init_heading_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "init-heading", '-',
                additional_error))
              goto failure;

          }
          /* set initial dive angle.  */
          else if (strcmp (long_options[option_index].name, "init-dive") == 0)
          {


            if (update_arg( (void *)&(args_info->init_dive_arg),
                 &(args_info->init_dive_orig), &(args_info->init_dive_given),
                &(local_args_info.init_dive_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "init-dive", '-',
                additional_error))
              goto failure;

          }
          /* set position North.  */
          else if (strcmp (long_options[option_index].name, "init-pos-N") == 0)
          {


            if (update_arg((void *)&(args_info->init_pos_N_flag), 0, &(args_info->init_pos_N_given),
                &(local_args_info.init_pos_N_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "init-pos-N", '-',
                additional_error))
              goto failure;

          }
          /* set position East.  */
          else if (strcmp (long_options[option_index].name, "init-pos-E") == 0)
          {


            if (update_arg((void *)&(args_info->init_pos_E_flag), 0, &(args_info->init_pos_E_given),
                &(local_args_info.init_pos_E_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "init-pos-E", '-',
                additional_error))
              goto failure;

          }
          /* set position South.  */
          else if (strcmp (long_options[option_index].name, "init-pos-S") == 0)
          {


            if (update_arg((void *)&(args_info->init_pos_S_flag), 0, &(args_info->init_pos_S_given),
                &(local_args_info.init_pos_S_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "init-pos-S", '-',
                additional_error))
              goto failure;

          }
          /* set position West.  */
          else if (strcmp (long_options[option_index].name, "init-pos-W") == 0)
          {


            if (update_arg((void *)&(args_info->init_pos_W_flag), 0, &(args_info->init_pos_W_given),
                &(local_args_info.init_pos_W_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "init-pos-W", '-',
                additional_error))
              goto failure;

          }
          /* set position NE.  */
          else if (strcmp (long_options[option_index].name, "init-pos-NE") == 0)
          {


            if (update_arg((void *)&(args_info->init_pos_NE_flag), 0, &(args_info->init_pos_NE_given),
                &(local_args_info.init_pos_NE_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "init-pos-NE", '-',
                additional_error))
              goto failure;

          }
          /* set position SE.  */
          else if (strcmp (long_options[option_index].name, "init-pos-SE") == 0)
          {


            if (update_arg((void *)&(args_info->init_pos_SE_flag), 0, &(args_info->init_pos_SE_given),
                &(local_args_info.init_pos_SE_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "init-pos-SE", '-',
                additional_error))
              goto failure;

          }
          /* set position SW.  */
          else if (strcmp (long_options[option_index].name, "init-pos-SW") == 0)
          {


            if (update_arg((void *)&(args_info->init_pos_SW_flag), 0, &(args_info->init_pos_SW_given),
                &(local_args_info.init_pos_SW_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "init-pos-SW", '-',
                additional_error))
              goto failure;

          }
          /* set position NW.  */
          else if (strcmp (long_options[option_index].name, "init-pos-NW") == 0)
          {


            if (update_arg((void *)&(args_info->init_pos_NW_flag), 0, &(args_info->init_pos_NW_given),
                &(local_args_info.init_pos_NW_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "init-pos-NW", '-',
                additional_error))
              goto failure;

          }
          /* set position center.  */
          else if (strcmp (long_options[option_index].name, "init-pos-center") == 0)
          {


            if (update_arg((void *)&(args_info->init_pos_center_flag), 0, &(args_info->init_pos_center_given),
                &(local_args_info.init_pos_center_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "init-pos-center", '-',
                additional_error))
              goto failure;

          }
          /* set initial latitude for ortho mode.  */
          else if (strcmp (long_options[option_index].name, "init-ortho-lat") == 0)
          {


            if (update_arg( (void *)&(args_info->init_ortho_lat_arg),
                 &(args_info->init_ortho_lat_orig), &(args_info->init_ortho_lat_given),
                &(local_args_info.init_ortho_lat_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "init-ortho-lat", '-',
                additional_error))
              goto failure;

          }
          /* set initial longitude for ortho mode.  */
          else if (strcmp (long_options[option_index].name, "init-ortho-lon") == 0)
          {


            if (update_arg( (void *)&(args_info->init_ortho_lon_arg),
                 &(args_info->init_ortho_lon_orig), &(args_info->init_ortho_lon_given),
                &(local_args_info.init_ortho_lon_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "init-ortho-lon", '-',
                additional_error))
              goto failure;

          }
          /* set initial ortho-view width [km].  */
          else if (strcmp (long_options[option_index].name, "init-ortho-width") == 0)
          {


            if (update_arg( (void *)&(args_info->init_ortho_width_arg),
                 &(args_info->init_ortho_width_orig), &(args_info->init_ortho_width_given),
                &(local_args_info.init_ortho_width_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "init-ortho-width", '-',
                additional_error))
              goto failure;

          }
          /* set platt projection.  */
          else if (strcmp (long_options[option_index].name, "projection-cyl-platt") == 0)
          {


            if (update_arg((void *)&(args_info->projection_cyl_platt_flag), 0, &(args_info->projection_cyl_platt_given),
                &(local_args_info.projection_cyl_platt_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "projection-cyl-platt", '-',
                additional_error))
              goto failure;

          }
          /* set cylindric projection 1.  */
          else if (strcmp (long_options[option_index].name, "projection-cyl-no1") == 0)
          {


            if (update_arg((void *)&(args_info->projection_cyl_no1_flag), 0, &(args_info->projection_cyl_no1_given),
                &(local_args_info.projection_cyl_no1_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "projection-cyl-no1", '-',
                additional_error))
              goto failure;

          }
          /* set pseudocylindric projection 1.  */
          else if (strcmp (long_options[option_index].name, "projection-pseudo-cyl-no1") == 0)
          {


            if (update_arg((void *)&(args_info->projection_pseudo_cyl_no1_flag), 0, &(args_info->projection_pseudo_cyl_no1_given),
                &(local_args_info.projection_pseudo_cyl_no1_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "projection-pseudo-cyl-no1", '-',
                additional_error))
              goto failure;

          }
          /* set mercator projection.  */
          else if (strcmp (long_options[option_index].name, "projection-cyl-mercator") == 0)
          {


            if (update_arg((void *)&(args_info->projection_cyl_mercator_flag), 0, &(args_info->projection_cyl_mercator_given),
                &(local_args_info.projection_cyl_mercator_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "projection-cyl-mercator", '-',
                additional_error))
              goto failure;

          }

          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */




  cmdline_parser_release (&local_args_info);

  if ( error_occurred )
    return (EXIT_FAILURE);

  return 0;

failure:

  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
